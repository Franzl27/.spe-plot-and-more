import tkinter as tk
from tkinter import filedialog, colorchooser, ttk, font, messagebox
from datetime import datetime
import json
import random
import sys
import platform
import os
import itertools
import math
import subprocess
import re
import shutil

try:
	import pandas as pd #for excelexport
	from openpyxl import Workbook #for excelexport
except:
	print("Pandas or openpyxl import failed!")

#Diese Datei enthält Code unter der MIT Lizenz
#sie enthält auch Code (pyGnuplot bzw die gp Klasse) von Ben Schneider (c) 2018 (MIT) - Danke dafür!
#Copyright (c) 2024 Sebastian von Döllen
#Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
#THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 

file_choose_lines = 100

#####PyGnuplot begins here # PyGnuplot begins here#############
from subprocess import PIPE, Popen#, CREATE_NO_WINDOW #CREATE_NO_WINDOW gibts aber nur unter Windows
from threading import Thread
from time import sleep

try:
	from queue import Queue, Empty  # Python 3.x
except ImportError:
	from Queue import Queue, Empty  # Python 2.x

ON_POSIX = 'posix' in sys.builtin_module_names

livet = 0
realt = 0
exportGPfile = False


class gp(object):
	def __init__(self):
		if platform.system() == "Windows":
			# Für Windows: Nutze den eingebetteten Gnuplot-Ordner
			base_path = getattr(sys, '_MEIPASS', os.path.dirname(os.path.abspath(__file__)))
			gnuplot_path = os.path.join(base_path, "gnuplot", "bin", "gnuplot.exe")
		else:
			# Für Linux: Nutze das System-Gnuplot
			gnuplot_path = "gnuplot"

		self.gnuplot_address = gnuplot_path

		self.p = Popen([self.gnuplot_address], stdin=PIPE, stderr=PIPE, stdout=PIPE,
					   bufsize=1, shell=False, universal_newlines=True) #, creationflags=subprocess.CREATE_NO_WINDOW #geht nur unter Windows, aber hilft die Gnuplot-Konsole zu verstecken

		self.q_err = Queue()
		self.t_err = Thread(target=self.enqueue_std, args=(self.p.stderr, self.q_err))
		self.t_err.daemon = True
		self.t_err.start()
		self.q_out = Queue()
		self.t_out = Thread(target=self.enqueue_std, args=(self.p.stdout, self.q_out))
		self.t_out.daemon = True
		self.t_out.start()
		self.r()  # clear return buffer

	def enqueue_std(self, out, queue):
		for line in iter(out.readline, ''):
			queue.put(line)
		out.close()

	def c(self, command):
		self.p.stdin.write(command + '\n')
		self.p.stdin.flush()

	def r(self, vtype=str, timeout=0.05):
		lines = []
		while True:
			try:
				line = self.q_err.get(timeout=timeout)
				lines.append(vtype(line.strip()))
			except Empty:
				break
		return lines
		
	def a(self, command='', vtype=str, timeout=0.05):
		''' ask gnuplot (write and get answer)
		>>> a('print pi')
		'''
		self.c(command)
		sleep(0.01)  # wait 10ms for gnuplot
		return self.r(vtype, timeout)

	def m_str(self, data, delimiter=' '):
		''' turn data into string format 
		this string format can be used when sending data to gnuplot
		usually via: plot "-" u 1:2 w lp'''
		xy = list(zip(*data))
		ascii_st = ''
		for i in xy:
			for j in i:
				ascii_st += str(j) + delimiter
			ascii_st += '\n'
		return ascii_st

	def plot(self, data, com='plot "-" u 1:2 w lp'):
		''' quick plot data in gnuplot
			it basically pipes the data to gnuplot and plots it
			default plot :
			com = "plot "-" u 1:2 w lp"
		'''
		str_data = self.m_str(data)
		self.c(com)
		self.c(str_data+'e')  # add end character to plot string
		return self.r()

	def fit(self, data, func='y(x)=a + b*x', via='a,b', limit=1e-9, filename='tmp.dat', wait=1):
		'''simple quick way to fit with gnuplot
		this fit function temporarily stores the data in a file.
		Inputs:
			func : fitting function y(x) or f(x,y) or ...
			via : space separated variables to fit
			data : data set to fit
			filename : location where it can temporarily store its data
			wait : timing in s on how long to wait for the fit results
		Outputs:
			fit results in same order as via is defined
			report generated by gnuplot
		'''
		self.save(data, filename=filename)
		func_name = func.split('=')[0]
		self.c(func)  # 'y(x)=a+b*x'
		self.c('set fit limit '+str(limit))
		self.c('fit ' + func_name + ' "' + filename + '" via ' + via)
		sleep(wait) # wait until fitting is done
		report = self.a() # if no report is returned maybe increase the wait time here
		return self.get_variables(via), report

	def fit2d(self, data, func='y(x)=a + b*x', via='a,b', limit=1e-9):
		'''simple quick way to fit with gnuplot
		Inputs:
			func : fitting function y(x) or f(x,y) or ...
			via : space separated variables to fit
			data : data set to fit
		Outputs:
			fit results in same order as via is defined
			report generated by gnuplot
		'''
		str_data = self.m_str(data)
		func_name = func.split('=')[0]
		self.c(func)  # 'y(x)=a+b*x'
		self.c('set fit limit '+str(limit))
		self.c('fit ' + func_name + ' "-" via ' + via)
		report = self.a(str_data+'e')
		return self.get_variables(via), report

	def get_variables(self, via):
		'''
			returns values stored in gnuplot as given by via
		Inputs:
			via : for example via = 'a b c d e'
		Outputs:
			results in same order as via is given
		'''
		vals = via.split(',')
		ret = []
		for i in vals:
			r = self.a('print ' + i)
			try:
				r = float(r[0])  # hard coded conversion if possible
			except ValueError:
				pass
			ret.append(r)
		return ret

	def save(self, data, filename='tmp.dat', delimiter=' '):
		'''
		saves numbers arrays and text into filename (default = 'tmp.dat)
		(assumes equal sizes and 2D data sets)
		>>> s(data, filename='tmp.dat')  # overwrites/creates tmp.dat
		'''
		with open(filename, 'w') as f:
			filestr = self.m_str(data, delimiter=delimiter)
			f.write(filestr)
			f.close()  # write the rest and close

	def empty_plot(self):
		self.c('plot [][-1:1] 1/0 t""')

	def ps(self, filename='tmp.ps', width=14, height=9, fontsize=12):
		'''Script to make gnuplot print into a postscript file
		>>> ps(filename='myfigure.ps')  # overwrites/creates myfigure.ps
		'''
		self.c('set term postscript size '
			   + str(width) + 'cm, '
			   + str(height) + 'cm color solid '
			   + str(fontsize) + " font 'Calibri';")
		self.c('set out "' + filename + '";replot;')
		self.c('set term ' + self.default_term + ';replot')
		return self.r()

	def pdf(self, filename='tmp.pdf', width=8.8, height=6, fontscale=0.5):
		'''Script to make gnuplot print into a pdf file
		>>> pdf(filename='myfigure.pdf')  # overwrites/creates myfigure.pdf
		'''
		self.c('set term pdfcairo fontscale '
			   + str(fontscale) + 'size '
			   + str(width) + 'cm, '
			   + str(height) + "cm;")
		self.c('set out "' + filename + '";replot;')
		self.c('set term ' + self.default_term + '; replot')
		return self.r()  # clear buffer

	def quit(self):
		aa = self.a('exit')  # close gnuplot
		self.p.kill()  # kill pipe
		return aa

#####PyGnuplot ends here # PyGnuplot ends here#################
############################################

gp_script_list2 = ["""reset
set angle radians

#=================== Parameter ====================
a = 4.5     # Coefficient of lituus
k = 15      # 0 ≦ θ ≦ k*pi [rad]
n = 20      # Resolution
N = n * k

#=================== Function ====================
# Curve
x(t) = (t>0 ? a*cos(t)/sqrt(t) : 1/0)
y(t) = (t>0 ? a*sin(t)/sqrt(t) : 1/0)

# Title
title2(a, theta) = sprintf("{/:Italic x}({/:Italic θ})={/:Italic A}cos{/:Italic θ}/√{/:Italic θ}   \
{/:Italic y}({/:Italic θ})={/:Italic A}sin{/:Italic θ}/√{/:Italic θ}\n\n\
{/:Italic A}=%.2f  {/:Italic θ}=%d°",a, theta)

#=================== Plot Setup ====================
set terminal wxt size 900, 480 font 'Times New Roman, 20'
set nokey

set parametric
set size ratio -1
set samples 1e4
set tics font ', 16'
set xlabel '{/:Italic x}'
set ylabel '{/:Italic y}'
set xrange [-4:12]
set yrange [-4:4]
set xtics 2
set ytics 2
set grid

#=================== Animation Loop ====================
do for [i=0:N] {
    set title title2(a, 180/n * i) # [deg]
    h = pi/n * i                  # [rad]
    set trange [0:h]
    plot x(t), y(t) lw 1 lc 6, x(h), y(h) with points pt 7 ps 1 lc 6
    pause 0.05                    # Verzögerung zwischen Frames (50 ms)
}

"""]

gp_script_list = ["""reset
set angle radians

a = 4.5     
k = 15      
set title "Logarithmic spiral"
n = 20      

N = n * k

x(t) = (t>0 ? a*cos(t)/sqrt(t) : 1/0)
y(t) = (t>0 ? a*sin(t)/sqrt(t) : 1/0)



set terminal wxt size 900, 480 font 'Times New Roman, 20'
set nokey

set parametric
set size ratio -1
set samples 1e4
set tics font ', 16'
set xlabel '{/:Italic x}'
set ylabel '{/:Italic y}'
set xrange [-4:12]
set yrange [-4:4]
set xtics 2
set ytics 2
set grid

do for [i=0:N] {
 
    h = pi/n * i                  
    set trange [0:h]
    plot x(t), y(t) lw 1 lc 6, x(h), y(h) with points pt 7 ps 1 lc 6
    pause 0.05                    
}
""","""reset
set angle radians

#=================== Parameter ====================
a = 4.5     # Coefficient of lituus
k = 15      # 0 ≦ θ ≦ k*pi [rad]
n = 20      # Resolution
N = n * k

#=================== Function ====================
# Curve
x(t) = (t>0 ? a*cos(t)/sqrt(t) : 1/0)
y(t) = (t>0 ? a*sin(t)/sqrt(t) : 1/0)


#=================== Plot Setup ====================
set terminal wxt size 900, 480 font 'Times New Roman, 20'
set nokey

set parametric
set size ratio -1
set samples 1e4
set tics font ', 16'
set xlabel '{/:Italic x}'
set ylabel '{/:Italic y}'
set xrange [-4:12]
set yrange [-4:4]
set xtics 2
set ytics 2
set grid

#=================== Animation Loop ====================
do for [i=0:N] {
    h = pi/n * i                  # [rad]
    set trange [0:h]
    plot x(t), y(t) lw 1 lc 6, x(h), y(h) with points pt 7 ps 1 lc 6
    pause 0.05                    # Verzögerung zwischen Frames (50 ms)
}
""","""reset
set term wxt size 800,600 enhanced font 'Verdana,10'
set xrange [-10:10]
set yrange [-2:2]
set grid
set xlabel "X"
set ylabel "Amplitude"

do for [t=0:100] {
    plot sin(x - t/10.0) with lines lw 2 lc rgb "blue" title "Welle", \
         cos(x - t/10.0) with lines lw 2 lc rgb "red" title "Phase verschoben"
    pause 0.05
}
""","""reset
set term wxt size 1024,768 enhanced font 'Verdana,10'

# Einstellungen für die Ansicht
set zeroaxis
set isosamples 100
set hidden3d

# Frame-Parameter
angle_x = 45
frame_index = 0

# Interaktive Anzeige
do for [frame_index=0:359] {
    set view angle_x, frame_index % 360
    splot [-2*pi:2*pi][-2*pi:2*pi] sin((x + frame_index / 100.0)**2 + (y)**2) / ((x + frame_index / 100.0)**2 + (y)**2) with lines
    pause 0.1
}
""","""reset
set term wxt size 800,600 enhanced font 'Verdana,10'
set xrange [-10:10]
set yrange [-10:10]
set zrange [-1:1]
set hidden3d
set isosamples 50
set ticslevel 0
set xlabel "X"
set ylabel "Y"
set zlabel "Amplitude"

do for [angle=0:360:5] {
    set view 60, angle
    splot sin(sqrt(x**2 + y**2) - angle/30.0) / sqrt(x**2 + y**2) with lines lc rgb "dark-green" title "Rotierende Welle"
    pause 0.1
}
""","""# Setting ----------------------------------------
reset
set nokey
set term wxt size 854,480 enhanced font 'Times New Roman,18'

set xr[-40:40]
set yr[-40:40]
set xl 'x' font 'Times New Roman:Italic, 20'
set yl 'y' font 'Times New Roman:Italic, 20'
set tics font 'Times New Roman,18'

set size ratio -1
set grid

# Parameter ----------------------------------------
m1  = 1.0              # mass of bob
m2  = 1.5
l1  = 23.0             # length of link
l2  = 16.0
g  = 9.81              # gravitational acceleration
dt   = 0.01            # step
M  = m2 / (m1+m2)      # coefficient
l  = l2 / l1
omega2 = g / l1
dx  = dt/6
limit = 4000           # loop limit
R  = 1                 # radius of bob
r  = 0.1               # radius of trajectory

# Runge-Kutta 4th ----------------------------------------
f1(a, b, c, d) = c     # theta1'
f2(a, b, c, d) = d     # theta2'
f3(a, b, c, d) = (omega2*l*(-sin(a)+M*cos(a-b)*sin(b))-M*l*(c**2*cos(a-b)+l*d**2)*sin(a-b)) / (l-M*l*(cos(a-b))**2)
f4(a, b, c, d) = (omega2*cos(a-b)*sin(a)-omega2*sin(b)+(c**2+M*l*d**2*cos(a-b))*sin(a-b)) / (l-M*l*(cos(a-b))**2)


# Plot ----------------------------------------
# Initial Value
x1 = 3.5*pi/6         # theta1
x2 = 4.5*pi/6         # theta2
x3 = 0.0              # theta1'
x4 = 0.0              # theta2'
t  = 0.0              # time

# Initialize interactive display
do for [i = 1:limit] {
    # Calculate using Runge-Kutta 4th
    t = t + dt
    k11 = f1(x1, x2, x3, x4)
    k12 = f2(x1, x2, x3, x4)
    k13 = f3(x1, x2, x3, x4)
    k14 = f4(x1, x2, x3, x4)
    k21 = f1(x1+dt/2*k11, x2+dt/2*k12, x3+dt/2*k13, x4+dt/2*k14 )
    k22 = f2(x1+dt/2*k11, x2+dt/2*k12, x3+dt/2*k13, x4+dt/2*k14 )
    k23 = f3(x1+dt/2*k11, x2+dt/2*k12, x3+dt/2*k13, x4+dt/2*k14 )
    k24 = f4(x1+dt/2*k11, x2+dt/2*k12, x3+dt/2*k13, x4+dt/2*k14 )
    k31 = f1(x1+dt/2*k21, x2+dt/2*k22, x3+dt/2*k23, x4+dt/2*k24 )
    k32 = f2(x1+dt/2*k21, x2+dt/2*k22, x3+dt/2*k23, x4+dt/2*k24 )
    k33 = f3(x1+dt/2*k21, x2+dt/2*k22, x3+dt/2*k23, x4+dt/2*k24 )
    k34 = f4(x1+dt/2*k21, x2+dt/2*k22, x3+dt/2*k23, x4+dt/2*k24 )
    k41 = f1(x1+dt*k31,  x2+dt*k32,  x3+dt*k33,  x4+dt*k34 )
    k42 = f2(x1+dt*k31,  x2+dt*k32,  x3+dt*k33,  x4+dt*k34 )
    k43 = f3(x1+dt*k31,  x2+dt*k32,  x3+dt*k33,  x4+dt*k34 )
    k44 = f4(x1+dt*k31,  x2+dt*k32,  x3+dt*k33,  x4+dt*k34 )

    # Update angle and angular velocity
    x1 = x1 + dx * (k11 + 2*k21 + 2*k31 + k41)
    x2 = x2 + dx * (k12 + 2*k22 + 2*k32 + k42)
    x3 = x3 + dx * (k13 + 2*k23 + 2*k33 + k43)
    x4 = x4 + dx * (k14 + 2*k24 + 2*k34 + k44)

    # Draw links
    set arrow 1 nohead lw 2 from 0, 0 to l1*sin(x1), -l1*cos(x1) lc -1
    set arrow 2 nohead lw 2 from l1*sin(x1), -l1*cos(x1) to l1*sin(x1)+l2*sin(x2), -(l1*cos(x1)+l2*cos(x2)) lc -1

    # Draw bobs
    set object 1 circle at l1*sin(x1), -l1*cos(x1) fc rgb "blue" size R fs solid front
    set object 2 circle at l1*sin(x1)+l2*sin(x2), -(l1*cos(x1)+l2*cos(x2)) fc rgb "red" size R fs solid front

	plot 0
    # Redraw every 10 steps
    if (i % 10 == 0) {
        replot
    }
}
""","""set xyplane at -1.5
set view 70, 125
set grid lw 2
unset key

i=10
iy_min=-10
y_min=-10
y_max=20
while (i<200){
splot [-2:2][y_min:y_max][-1.5:1.5] sample \
                               [a=iy_min:i:0.2] '+' using (cos(a)):(a):(sin(a)) lt 5 lc rgb 'purple' lw 3,\
                               [a=iy_min:i:0.1] '' using (cos(a)):(y_min):(sin(a)) w l lw 2, \
                               [a=iy_min:i:0.1] '' using (-2):(a):(sin(a)) w l lw 2, \
                               [a=iy_min:i:0.1] '' using (cos(a)):(a):(-1.5) w l lw 2, \
                               [c=iy_min:i] '' using (cos(i)):(c):(sin(i)) w l lc rgb 'dark-green',\
                               [e=-2:cos(i)] '' using (e):(i):(sin(i)) w l lc rgb 'dark-blue',\
                               [f=-1.5:sin(i)] '' using (cos(i)):(i):(f) w l lc rgb 'dark-orange'
#                               [e=-2:1] '' using (e):(0):(0) w l lc rgb 'dark-red',\
#                               [f=-10:0] '' using (1):(f):(0) w l lc rgb 'dark-red'
i=i+0.098
y_min=y_min+0.1
y_max=y_max+0.1
pause 0.01
}

pause -1"""]

custom_commands = """#set label 1 sprintf("Ra-Da") at graph .401, graph 0.3 tc rgb "blue"') 
#set arrow from graph -0.05, graph 0.175 to -10, 3*3 lt 1 lc rgb "blue"')
#set object 1 circle at 500,100 size 250"""

if getattr(sys, 'frozen', False):  # Wenn das Programm als .exe ausgeführt wird
    app_path = os.path.dirname(sys.executable)
else:  # Wenn das Skript direkt mit Python ausgeführt wird
    app_path = os.path.dirname(os.path.abspath(__file__))
app_path = app_path.replace("\\","/")
# Datei zum Speichern der Konfiguration
# ~ CONFIG_FILE = "plotConfig.json"
CONFIG_FILE = os.path.join(app_path, 'plotConfig.json')
CONFIG_FILE = CONFIG_FILE.replace("\\","/")

tmp_file = os.path.join(app_path, 'tmp.dat')
tmp_file = tmp_file.replace("\\","/")
# ~ CONFIG_FILE = os.path.join(app_path, 'config.json')
# Standardwerte
DEFAULT_CONFIG = [
	{
		"file_path": "",
		"button_color": None,  # Zufällige Farbe wird bei Start gesetzt
		"dropdown_value": "line",
		"small_text": ""
	}
	for _ in range(file_choose_lines)
]

EXTRA_CONFIG = [
	{
		"xlabel": "Energy [keV]",
		"x2label": "Energy [keV]",
		"xrange1": "",  # 
		"xrange2": "",  # 
		"ylabel": "Counts",  # 
		"y2label": "Counts",  # 
		"yrange1": "",  #
		"yrange2": "",  
		"gridcheck": False,
		"logcheck": False,
		"logx": False,
		"ytics": True,
		"xtics": True,
		"showx1": True,
		"showy1": True,
		"showx2": False,
		"showy2": False,
		"plotstyle": "Filled steps",
		"outputradio": "interactive window",
		"plotway" : "Single plot energy",
		"outputname" : "Output",
		"displayroi" : True,
		"roicolor" : None,
		"bordercolor" : "#000000",
		"xcolor" : "#000000",
		"ycolor" : "#000000",
		"x1color" : "#000000",
		"y2color" : "#000000",
		"x2color" : "#000000",
		"y1color" : "#000000",
		"trans_var": "0.5",
		"transparency": "0.5",
		"eff_var": "1",
		"title_var": "",
		"key_placement": "top right in",
		"border_var": "1",
		"borderwidth": "1",
		"file_count": "5",
		"offset_var": "0",
		"xoffset_var": "0",
		"divliv_var": False,
		"automation_var": "No automation",
		"customcommands": custom_commands,
		"comment_var": "This standard text may be replaced by an arbitrary text, is stored in the json config file and may be used as a comment field!"
	}
]

# Konfiguration laden
def load_config():
	if os.path.exists(CONFIG_FILE):
		try:
			with open(CONFIG_FILE, "r") as f:
				configs = json.load(f)
			config1 = configs["config1"]
			config2 = configs["config2"]
			return config1, config2
		except:
			print("Warnung: Konfigurationsdatei ist beschädigt. Standardwerte werden verwendet.")
			print("Try to delete the JSON config file, this should help!")
	return DEFAULT_CONFIG, EXTRA_CONFIG



# Konfiguration speichern
def save_config(config1,config2):
	configs = {
		"config1": config1,
		"config2": config2
	}
	with open(CONFIG_FILE, "w") as f:
		json.dump(configs, f, indent=4)


def handle_arguments():
	# Überprüfen, ob keine Argumente vorhanden sind
	noargs = len(sys.argv) == 1

	# Filtere ungültige Argumente (z. B. eingebundene Datei)
	valid_args = [
		arg for arg in sys.argv[1:]
		if arg.lower().endswith((".spe", ".sep"))  # Ignoriere Groß-/Kleinschreibung
	]

	# neeee:Wenn mehr als 10 valide Argumente vorhanden sind, eine neue Instanz starten
	# ~ if len(valid_args) > file_choose_lines:
		# ~ new_args = valid_args[file_choose_lines:]
		# ~ subprocess.Popen([sys.executable, __file__] + new_args)
		# ~ sys.argv = [sys.argv[0]] + valid_args[:file_choose_lines]  # Begrenze die aktuellen Argumente
	sys.argv = [sys.argv[0]] + valid_args[:]
	return noargs




# ~ def handle_arguments(): #DAS AUCH VON GPT FUNZT ABA MA SO GAHHHH NEDDDD1111!!!!11!!!
	# ~ # Erkenne das temporäre Verzeichnis von PyInstaller
	# ~ pyinstaller_temp_dir = getattr(sys, '_MEIPASS', None)
	
	# ~ #DEBUG
	# ~ print(sys.argv)
	
	# ~ # Filtere nur das temporäre Verzeichnis aus den Argumenten
	# ~ sys.argv = [arg for arg in sys.argv if arg != pyinstaller_temp_dir]

	# ~ # Überprüfen, ob keine Argumente vorhanden sind
	# ~ noargs = len(sys.argv) == 1

	# ~ # Wenn mehr als 10 Argumente vorhanden sind, eine neue Instanz aufrufen
	# ~ if len(sys.argv) > 11:
		# ~ new_args = sys.argv[11:]
		# ~ subprocess.Popen([sys.executable, __file__] + new_args)
		# ~ sys.argv = sys.argv[:11]  # Begrenze die aktuellen Argumente auf die ersten 10

	# ~ return noargs

# ~ def handle_arguments(): #das ist die "original"-version die den bug hat
	# ~ # Überprüfen, ob keine Argumente vorhanden sind
	# ~ noargs = len(sys.argv) == 1

	# ~ # Wenn mehr als 10 Argumente vorhanden sind, eine neue Instanz aufrufen
	# ~ if len(sys.argv) > 11:
		# ~ new_args = sys.argv[11:]
		# ~ subprocess.Popen([sys.executable, __file__] + new_args)
		# ~ sys.argv = sys.argv[:11]  # Begrenze die aktuellen Argumente auf die ersten 10

	# ~ return noargs




# Funktion für zufällige Farbe
def random_color():
	return f"#{random.randint(0, 0xFFFFFF):06x}"
	
def copy_data_file():
	# Bestimme den Pfad der eingebundenen Datei
	if getattr(sys, 'frozen', False):
		# Falls das Skript als .exe läuft
		bundle_dir = sys._MEIPASS
	else:
		# Falls das Skript als Python-Datei läuft
		bundle_dir = os.path.dirname(os.path.abspath(__file__))
	
	data_file_path = os.path.join(bundle_dir, 'plotSPE.py')
	
	# Kopiere die Datei ins aktuelle Arbeitsverzeichnis
	shutil.copy(data_file_path, os.getcwd())
	print(f"Datei {data_file_path} wurde ins Arbeitsverzeichnis kopiert.")	
	

def prepend_roi_list(input_list):
	# Erstelle eine neue Liste mit "$ROI:", der Länge der Eingabeliste und den Elementen der Eingabeliste
	result_list = ["$ROI:", str(len(input_list))] + input_list
	return result_list

def trim_roi_list(input_list):
	# Überprüfen, ob die Liste "$ROI:" enthält und das Format passt
	if len(input_list) > 1 and input_list[0] == "$ROI:":
		try:
			num_elements = int(input_list[1])  # Zahl nach "$ROI:" lesen
			remove_count = num_elements + 2   # Anzahl der zu entfernenden Elemente
			return input_list[remove_count:]  # Liste ab dem entsprechenden Index zurückgeben
		except ValueError:
			raise ValueError("Das zweite Element nach '$ROI:' muss eine Zahl sein.")
	else:
		raise ValueError("Die Liste muss mit '$ROI:' beginnen und mindestens zwei Elemente enthalten.")


def save_output_file(unique_output_name, temp_list, countlist):
	try:
		with open(unique_output_name, "w") as file:
			# Schreiben der Elemente von temp_list[10] in einzelnen Zeilen
			skip_next = False
			if len(temp_list) > 10:
				if isinstance(temp_list[10], list):
					for line in temp_list[10]:
						if skip_next:
							skip_next = False
							continue
							
						file.write(line + "\n")
						print("Written line from temp_list[10]:", line)
						
						if line == "$MEAS_TIM:":
							file.write(f"{livet} {realt}\n")
							print("Written custom line:", f"{livet} {realt}")
							skip_next = True
				else:
					file.write(temp_list[10] + "\n")
					print("Written temp_list[10]:", temp_list[10])
			else:
				print("temp_list[10] is missing!")
			
			# Schreiben des Inhalts von countlist mit 7 führenden Leerzeichen
			if countlist:
				file.write('0 ' + str(len(countlist)-1) + '\n')
				for count in countlist:
					file.write("       " + str(count) + "\n")
					print("Written count:", count)
			else:
				print("countlist is empty!")
			
			# Schreiben der Elemente von temp_list[11] in einzelnen Zeilen
			if len(temp_list) > 11:
				if isinstance(temp_list[11], list):
					for line in temp_list[11]:
						if skip_next:
							skip_next = False
							continue
						file.write(line + "\n")
						print("Written line from temp_list[11]:", line)
						
						if line == "Live Time":
							file.write(str(livet) + "\n")
							print("Written custom Live Time")
							skip_next = True
				else:
					file.write(temp_list[11] + "\n")
					print("Written temp_list[11]:", temp_list[11])
			else:
				print("temp_list[11] is missing!")
		
		print(f"File successfully saved as: {unique_output_name}")
	except Exception as e:
		print(f"An error occurred while writing the file: {e}")

def check_and_handle_negatives(countlist, automatisch = False, subzero = False):
	# Prüfen, ob es negative Zahlen in der Liste gibt
	if any(value < 0 for value in countlist):
		# tkinter-Root-Objekt erstellen
		# ~ root = tk.Tk()
		# ~ root.withdraw()  # Versteckt das Hauptfenster
		
		# Ja/Nein-MessageBox anzeigen
		if not automatisch:
			response = messagebox.askyesno(
				"Keep negative counts?",
				"Your subtraction yielded negative values.\n"
				"Set them to 0 for plotting? (No) \n"
				"Keep them for purposes? (Yes)"
			)
		else:
			response = subzero
		
		if not response:  # Wenn die Antwort "Nein" ist
			# Alle negativen Werte auf 0 setzen
			countlist = [max(value, 0) for value in countlist]
		
		# ~ root.destroy()  # tkinter schließen
	return countlist

def find_roi(file_path):
	"""
	Liest den ROI-Bereich aus einer Datei basierend auf der Zeile mit "$ROI:".

	Args:
		file_path (str): Der Pfad zur Textdatei.

	Returns:
		list: Eine Liste mit den eingelesenen Zeilen im ROI-Bereich.
	"""
	roi_lines = []

	try:
		with open(file_path, 'r') as file:
			lines = file.readlines()
		
		# Suche nach der Zeile mit "$ROI:"
		for i, line in enumerate(lines):
			if line.strip() == "$ROI:":
				# Nächste Zeile enthält die Anzahl
				count = int(lines[i + 1].strip())
				# ROI-Bereich einlesen
				roi_lines = lines[i + 2:i + 2 + count]
				break

	except (IOError, ValueError, IndexError) as e:
		print(f"Fehler beim Verarbeiten der Datei: {e}")
	
	return [line.strip() for line in roi_lines]


def parse_and_merge_intervals(interval_strings):
	"""
	Wandelt eine Liste von Strings (Zahlenpaaren) in echte Intervalle um, überprüft auf Überschneidungen,
	fasst diese zusammen und gibt die Liste als Strings zurück.

	Args:
		interval_strings (list): Eine Liste von Strings, z. B. ['185 195', '245 263', ...]

	Returns:
		list: Eine sortierte Liste der zusammengefassten Intervalle als Strings ['x1 y1', 'x2 y2', ...].
	"""
	# Strings in Zahlenpaare umwandeln
	intervals = [tuple(map(int, s.split())) for s in interval_strings]
	
	# Funktion zur Verschmelzung aufrufen
	merged_intervals = merge_intervals(intervals)

	# Konvertiere die Tupel zurück in Strings
	return [f"{x[0]} {x[1]}" for x in merged_intervals]

	

def merge_intervals(intervals):
	"""
	Fasst sich überschneidende Intervalle zusammen und sortiert die Liste aufsteigend.

	Args:
		intervals (list): Eine Liste von Zahlenpaaren [(x1, y1), (x2, y2), ...].

	Returns:
		list: Eine Liste der zusammengefassten und sortierten Intervalle.
	"""
	if not intervals:
		return []

	# Sortiere die Intervalle nach dem ersten Wert
	intervals.sort(key=lambda x: x[0])

	merged = [intervals[0]]

	for current in intervals[1:]:
		previous = merged[-1]
		# Überprüfen, ob sich die Intervalle überschneiden
		if current[0] <= previous[1]:
			# Zusammenfassen der Intervalle
			merged[-1] = (previous[0], max(previous[1], current[1]))
		else:
			# Kein Überschneiden, Intervall hinzufügen
			merged.append(current)

	return merged

def find_roi_index(lines):
	"""
	Sucht in einer Liste nach der ersten Zeile mit "$ROI:" und gibt deren Index zurück.

	Args:
		lines (list): Eine Liste von Strings, in der gesucht wird.

	Returns:
		int: Der Index der ersten Zeile mit "$ROI:", oder -1, falls sie nicht gefunden wurde.
	"""
	try:
		return lines.index("$ROI:")
	except ValueError:
		return -1
	
def process_nested_list(nested_list, prefixes):
	"""
	Flatten a nested list, remove line breaks from all elements,
	prepend each element with a unique prefix from a given list, and return a single concatenated string.

	Parameters:
		nested_list (list): A list that may contain other lists or strings with line breaks.
		prefixes (list): A list of prefixes, each corresponding to an element in the flattened list.

	Returns:
		str: A single string with all processed elements concatenated.
	"""
	flat_list = []

	# Flatten the list
	for item in nested_list:
		if isinstance(item, list):
			flat_list.extend(item)  # Add elements of sublist
		else:
			flat_list.append(item)  # Add single element

	# Ensure prefixes list matches the number of elements in the flat list
	if len(prefixes) != len(flat_list):
		raise ValueError("The number of prefixes must match the number of elements in the nested list.")

	# Remove line breaks and prepend each element with its corresponding prefix
	processed_list = [prefix + str(element).strip() for prefix, element in zip(prefixes, flat_list)]

	# Combine all elements into a single string
	return "".join(processed_list)

def generate_plots_with_counts(plotlines, gpc_indices):
	# Startpunkt setzen
	current_index = 0
	results = []
	
	# Erste Anzahl aus gpc_indices hinzufügen
	for i, count in enumerate(gpc_indices):
		# Anzahl der Elemente ermitteln
		num_elements = count - current_index if i > 0 else count
		# Elemente extrahieren und an den Plot-String anhängen
		plot_string = "plot " + ", ".join(plotlines[current_index:current_index + num_elements])
		results.append(plot_string)
		# Index aktualisieren
		current_index += num_elements
	
	# Den Rest von plotlines hinzufügen
	if current_index < len(plotlines):
		plot_string = "plot " + ", ".join(plotlines[current_index:])
		results.append(plot_string)
	
	return results 

# ~ print(parse_and_merge_intervals(find_roi('Tc08.Spe')))


def parse_file(filepath): #spe dateien generell einlesen mit bedingungen vom anfang
	# Liste, die die geforderten Informationen speichert
	result = []

	# Pfad und Basisname ohne Dateiendung hinzufügen
	result.append(filepath)
	result.append(os.path.splitext(os.path.basename(filepath))[0])

	try:
		with open(filepath, 'r') as file:
			lines = file.readlines()

		# Suche nach den gewünschten Informationen
		meas_tim_index = next((i for i, line in enumerate(lines) if line.startswith("$MEAS_TIM")), None)
		data_index = next((i for i, line in enumerate(lines) if line.startswith("$DATA")), None)
		presets_index = next((i for i, line in enumerate(lines) if line.startswith("$PRESETS")), None)
		ener_fit_index = next((i for i, line in enumerate(lines) if line.startswith("$ENER_FIT")), None)
		mca_cal_index = next((i for i, line in enumerate(lines) if line.startswith("$MCA_CAL")), None)
		shape_cal_index = next((i for i, line in enumerate(lines) if line.startswith("$SHAPE_CAL")), None)

		# Zweite Einträge extrahieren
		result.append(lines[meas_tim_index + 1].strip() if meas_tim_index is not None else None)
		result.append(lines[data_index + 1].strip() if data_index is not None else None)
		result.append(data_index + 1 if data_index is not None else None)

		# Zwei Zeilen nach $PRESETS
		result.append(lines[presets_index + 1:presets_index + 3] if presets_index is not None else [])

		# Zeile nach $ENER_FIT
		result.append(lines[ener_fit_index + 1].strip() if ener_fit_index is not None else None)

		# Zwei Zeilen nach $MCA_CAL
		result.append(lines[mca_cal_index + 1:mca_cal_index + 3] if mca_cal_index is not None else [])

		# Zwei Zeilen nach $SHAPE_CAL
		result.append(lines[shape_cal_index + 1:shape_cal_index + 3] if shape_cal_index is not None else [])

		# Zeilen 13 bis 4108
		
		numbers = result[3].split() #determine how many channels
		second_numb = int(numbers[1])
		# ~ print("second numb:")
		# ~ print(second_numb)
		result.append([line.strip() for line in lines[result[4]+1:result[4]+1+second_numb+1]]) #count from channel 0 to channel end
		# Bereich vor "CHANNELS" (von Anfang bis result[4])
		result.append([line.strip() for line in lines[:result[4]]])

		# Bereich nach "CHANNELS" (ab result[4] + 1 + second_numb + 1 bis zum Ende)
		result.append([line.strip() for line in lines[result[4] + 1 + second_numb + 1 :]])
		# ~ result.append()

	except Exception as e:
		print(f"Fehler beim Verarbeiten von {filepath}: {e}")
		return None

	return result
	

		
	
def validate_efficy(eff_var):
	"""
	Validiert den Inhalt von eff_var. Wenn der Inhalt leer ist oder keine Zahl ist,
	wird die Variable eff_var auf 1 gesetzt.

	Parameter:
		eff_var (tk.StringVar): Die Variable, deren Inhalt geprüft wird.
	
	Returns:
		float: Der geprüfte und gegebenenfalls angepasste Wert von efficy.
	"""
	try:
		efficy = float(eff_var.get())
	except ValueError:
		efficy = 1  # Standardwert setzen, wenn ungültig
		eff_var.set(efficy)  # Variable aktualisieren
	return efficy
	
	
def parse_meta(filepath):
	# Liste, die die geforderten Informationen speichert
	result = []

	# Pfad und Basisname ohne Dateiendung hinzufügen
	# ~ result.append(filepath)
	# ~ result.append(os.path.splitext(os.path.basename(filepath))[0])

	try:
		with open(filepath, 'r') as file:
			lines = file.readlines()

		# Suche nach den gewünschten Informationen
		spec_id = next((i for i, line in enumerate(lines) if line.startswith("$SPEC_ID")), None)
		date_mea = next((i for i, line in enumerate(lines) if line.startswith("$DATE_MEA")), None)
		meas_tim_index = next((i for i, line in enumerate(lines) if line.startswith("$MEAS_TIM")), None)
		presets_index = next((i for i, line in enumerate(lines) if line.startswith("$PRESETS")), None)
		# ~ mca_cal_index = next((i for i, line in enumerate(lines) if line.startswith("$ENER_FIT")), None)
		ener_fit_index = next((i for i, line in enumerate(lines) if line.startswith("$ENER_FIT")), None)
		# ~ shape_cal_index = next((i for i, line in enumerate(lines) if line.startswith("$SHAPE_CAL")), None)

		# Zweite Einträge extrahieren
		result.append(lines[spec_id + 1].strip() if spec_id is not None else None)
		# ~ result.append(lines[data_index + 1].strip() if data_index is not None else None)
		# ~ result.append(data_index + 1 if data_index is not None else None)

		# Zwei Zeilen nach $PRESETS
		result.append(lines[presets_index + 1:presets_index + 3] if presets_index is not None else [])

		# Zeile nach $ENER_FIT
		result.append(lines[ener_fit_index + 1].strip() if ener_fit_index is not None else None)

		# Zwei Zeilen nach $MCA_CAL
		# ~ result.append(lines[mca_cal_index + 1:mca_cal_index + 3] if mca_cal_index is not None else [])

		# Zwei Zeilen nach $SHAPE_CAL
		# ~ result.append(lines[shape_cal_index + 1:shape_cal_index + 3] if shape_cal_index is not None else [])

		# Zeilen 13 bis 4108
		
		# ~ numbers = result[3].split() #determine how many channels
		# ~ second_numb = int(numbers[1])
		#print("second numb:")
		#print(second_numb)
		# ~ result.append([line.strip() for line in lines[result[4]+1:result[4]+1+second_numb+1]]) #count from channel 0 to channel end
		# ~ # Bereich vor "CHANNELS" (von Anfang bis result[4])
		# ~ result.append([line.strip() for line in lines[:result[4]]])

		# ~ # Bereich nach "CHANNELS" (ab result[4] + 1 + second_numb + 1 bis zum Ende)
		# ~ result.append([line.strip() for line in lines[result[4] + 1 + second_numb + 1 :]])
		# ~ result.append()

	except Exception as e:
		print(f"Fehler beim Verarbeiten von {filepath}: {e}")
		return None

	return result

# ~ def modify_list_of_lists(list_of_lists, additional_list):
	# ~ for sublist in list_of_lists:
		# ~ if "$ROI:" in sublist:
			# ~ roi_index = sublist.index("$ROI:")  # Index von "$ROI:"
			# ~ num_index = roi_index + 1  # Index der Zahl
			# ~ if num_index < len(sublist):
				# ~ num_elements = int(sublist[num_index])  # Anzahl Elemente
				# ~ sublist[num_index] = str(len(additional_list))  # Ersetze die Zahl
				# ~ # Ersetze die nachfolgenden Elemente durch die neue Liste
				# ~ sublist[num_index + 1:num_index + 1 + num_elements] = additional_list
			# ~ break  # Abbrechen, sobald die erste passende Unterliste gefunden wurde
	# ~ return list_of_lists


def ask_question(ttitle,ttext):
	# Öffnet ein Ja/Nein-Fenster
	answer = messagebox.askyesno(ttitle, ttext)
	# ~ if answer:
		# ~ print("Benutzer hat 'Ja' gewählt.")
	# ~ else:
		# ~ print("Benutzer hat 'Nein' gewählt.")
	return answer

def ensure_unique_filename(filename):
	# Get the file name without extension and the extension itself
	base, ext = os.path.splitext(filename)
	
	# Loop to check and modify the filename
	while os.path.exists(filename):
		base += "x"  # Append "b" to the base name
		filename = base + ext  # Combine with the original extension
	
	return filename

def write_to_file(file_path, content):
	"""
	Schreibt den angegebenen Inhalt in eine Textdatei.

	:param file_path: Pfad zur Textdatei, z.B. "example.txt"
	:param content: Der Inhalt, der in die Datei geschrieben werden soll (String).
	"""
	try:
		with open(file_path, "a") as file:  # 'w' steht für Schreibmodus a, bestehende Dateien werden appended
			file.write(content)
		#print(f"Inhalt wurde erfolgreich in '{file_path}' geschrieben.")
	except Exception as e:
		print(f"Fehler beim Schreiben in die Datei: {e}")	
# ~ print(parse_and_merge_intervals(find_roi('Tc08.Spe')))

def create_executable():
	try:
		import pyinstaller
	except ImportError:
		subprocess.check_call([sys.executable, "-m", "pip", "install", "pyinstaller"])

	# Bestimme den aktuellen Skript-Pfad
	script_path = os.path.abspath(__file__)

	# Baue den Befehl für pyinstaller
	command = [
		"pyinstaller", 
		"--onefile",  # Erstelle eine einzelne ausführbare Datei
		"--distpath", ".",  # Zielverzeichnis für die .exe oder ausführbare Datei (aktuelles Verzeichnis)
		"--workpath", ".",  # Arbeitsverzeichnis für temporäre Dateien (aktuelles Verzeichnis)
		script_path  # Das aktuelle Skript
	]

	# Führe den pyinstaller-Befehl aus
	subprocess.run(command, check=True)


def get_file_metadata(filename):
	stats = os.stat(filename)
	metadata = {
		"size": stats.st_size,  # Dateigröße in Bytes
		"creation_time": stats.st_ctime,  # Erstellzeit
		"modification_time": stats.st_mtime,  # Letzte Änderungszeit
		"access_time": stats.st_atime,  # Letzter Zugriff
	}
	return metadata

def get_file_metadata_string(filename):
	"""Liest Metadaten aus der Datei aus und gibt sie als schön formatierten String zurück."""
	# Allgemeine Informationen der Datei abrufen
	stats = os.stat(filename)
	
	# Zeitangaben in menschenlesbare Datumsformate konvertieren
	creation_time = datetime.fromtimestamp(stats.st_ctime).strftime("%Y-%m-%d %H:%M:%S")
	modification_time = datetime.fromtimestamp(stats.st_mtime).strftime("%Y-%m-%d %H:%M:%S")
	access_time = datetime.fromtimestamp(stats.st_atime).strftime("%Y-%m-%d %H:%M:%S")
	
	# Erstellen eines schön formatierten Strings
	metadata_string = (
		f"File: {filename} "
		f"Size: {stats.st_size} bytes "
		f"Creation Time: {creation_time} "
		f"Last Modification Time: {modification_time} "
		f"Last Access Time: {access_time}"
	)
	
	return metadata_string

def divide_nested_lists_by_efficy(nested_lists, efficy):
	"""
	Diese Funktion teilt jede Zahl in allen inneren Listen durch den gegebenen Wert efficy,
	ohne dabei die Listenstruktur zu verändern.

	Parameter:
		nested_lists (list): Eine Liste, die andere Listen enthält, wobei jede innere Liste nur Zahlen enthält.
		efficy (float): Der Wert, durch den jede Zahl geteilt werden soll.

	Rückgabewert:
		list: Eine neue Liste mit der gleichen Struktur wie `nested_lists`, aber die Zahlen wurden durch efficy geteilt.
	"""
	# Rekursiv durch jede innere Liste iterieren und Elemente durch efficy teilen
	return [[round(float(x) / float(efficy),4) for x in inner_list] for inner_list in nested_lists]

def divide_list_by_efficy(number_list, efficy):
	"""
	Teilt alle numerischen Elemente einer Liste (auch verschachtelte Listen) durch den Wert von efficy.

	Parameter:
		number_list (list): Die Liste der Zahlen oder verschachtelten Listen, die verarbeitet werden sollen.
		efficy (float): Der Wert, durch den die Zahlen geteilt werden.

	Returns:
		list: Eine Liste gleicher Struktur mit den berechneten Werten.
	"""
	if efficy == 0:
		raise ValueError("efficy darf nicht 0 sein, um eine Division durch 0 zu vermeiden.")

	def process_element(element):
		# Rekursiv verschachtelte Listen verarbeiten
		if isinstance(element, list):
			return [process_element(sub_element) for sub_element in element]
		elif isinstance(element, (int, float)):  # Nur numerische Typen verarbeiten
			return element / efficy
		else:
			raise TypeError(f"Unerwarteter Typ in der Liste: {type(element)}")
	
	return [process_element(item) for item in number_list]

def add_to_list_elements(input_list, value_to_add):
	"""
	Erhöht alle Werte einer Liste um eine gegebene Zahl.

	:param input_list: List of numbers (int or float)
	:param value_to_add: Number to add to each element of the list
	:return: New list with updated values
	"""
	return [element + int(value_to_add) for element in input_list]

def divide_list_by_livetime(number_list, livetime):
	"""
	Teilt alle Elemente einer Liste von Zahlen durch den Wert von efficy.

	Parameter:
		number_list (list of float): Die Liste der Zahlen, die geteilt werden sollen.
		efficy (float): Der Wert, durch den die Zahlen geteilt werden.

	Returns:
		list of float: Eine neue Liste mit den berechneten Werten.
	"""
	if livetime == 0:
		raise ValueError("livetime darf nicht 0 sein, um eine Division durch 0 zu vermeiden.")
	
	return [round(float(x) / float(livetime),4) for x in number_list]



#csv to xlsx
# ~ def csv_to_xlsx(csv_filename, xlsx_filename=None):
    # ~ """
    # ~ Converts a CSV file to an XLSX file.
    
    # ~ Parameters:
        # ~ csv_filename (str): The name of the CSV file to convert. Should include the .csv extension.
        # ~ xlsx_filename (str): The name of the output XLSX file. If None, the output will have the same 
                             # ~ name as the input CSV file, but with a .xlsx extension.
                             
    # ~ Returns:
        # ~ str: Path to the created XLSX file.
    # ~ """
    #import os
    
    # ~ # Import necessary modules
    # ~ try:
        # ~ import pandas as pd
    # ~ except ImportError:
        # ~ raise ImportError("The 'pandas' library is required but not installed. Install it with 'pip install pandas'.")
    
    # ~ try:
        # ~ from openpyxl import Workbook
    # ~ except ImportError:
        # ~ raise ImportError("The 'openpyxl' library is required but not installed. Install it with 'pip install openpyxl'.")
    
    # ~ # Ensure the input file exists
    # ~ if not os.path.isfile(csv_filename):
        # ~ raise FileNotFoundError(f"The file '{csv_filename}' was not found in the current directory.")
    
    # ~ # Set default XLSX filename if not provided
    # ~ if xlsx_filename is None:
        # ~ xlsx_filename = os.path.splitext(csv_filename)[0] + ".xlsx"
    
    # ~ # Load CSV into a DataFrame and save it as XLSX
    # ~ try:
        # ~ df = pd.read_csv(csv_filename, delimiter=' ', engine='python')
        # ~ df.to_excel(xlsx_filename, index=False, engine='openpyxl')
    # ~ except Exception as e:
        # ~ raise RuntimeError(f"An error occurred while converting '{csv_filename}' to '{xlsx_filename}': {e}")
    
    # ~ print(f"File '{csv_filename}' has been successfully converted to '{xlsx_filename}'.")
    # ~ return os.path.abspath(xlsx_filename)
def csv_to_xlsx(csv_filename, xlsx_filename=None):
    """
    Converts a space-delimited CSV file to an XLSX file in the same directory as the input file.
    
    Parameters:
        csv_filename (str): The name of the CSV file to convert. Should include the .csv extension.
        xlsx_filename (str): The name of the output XLSX file. If None, the output will have the same 
                             name as the input CSV file, but with a .xlsx extension.
                             
    Returns:
        str: Path to the created XLSX file.
    """
    #import os
    
    # Import necessary modules
    try:
        import pandas as pd
    except ImportError:
        raise ImportError("The 'pandas' library is required but not installed. Install it with 'pip install pandas'.")
    
    try:
        from openpyxl import Workbook
    except ImportError:
        raise ImportError("The 'openpyxl' library is required but not installed. Install it with 'pip install openpyxl'.")
    
    # Ensure the input file exists
    if not os.path.isfile(csv_filename):
        raise FileNotFoundError(f"The file '{csv_filename}' was not found in the current directory.")
    
    # Determine the output XLSX filename
    input_dir = os.path.dirname(csv_filename) or os.getcwd()
    if xlsx_filename is None:
        xlsx_filename = os.path.join(input_dir, os.path.splitext(os.path.basename(csv_filename))[0] + ".xlsx")
    else:
        xlsx_filename = os.path.join(input_dir, xlsx_filename)
    
    # Load CSV into a DataFrame and save it as XLSX
    try:
        df = pd.read_csv(csv_filename, delimiter=r'\s+', engine='python')
        df.to_excel(xlsx_filename, index=False, engine='openpyxl')
    except Exception as e:
        raise RuntimeError(f"An error occurred while converting '{csv_filename}' to '{xlsx_filename}': {e}")
    
    print(f"File '{csv_filename}' has been successfully converted to '{xlsx_filename}'.")
    return os.path.abspath(xlsx_filename)


#parse
def parse_text_file(file_path):
	"""
	Parses a text file, extracting specific sections based on $ markers.
	Handles both single-line and multi-line sections properly.
	"""
	try:
		with open(file_path, 'r') as file:
			lines = file.readlines()
	except Exception as e:
		return f"Error reading file: {e}"

	# Resultat-String-Liste
	results = []

	# Hilfsvariablen
	idx = 0
	total_lines = len(lines)

	while idx < total_lines:
		line = lines[idx].strip()

		# Abschnittskennung prüfen
		if line.startswith('$'):
			if line.startswith('$SPEC_ID:'):
				# ~ print("")
				# SPEC_ID hat eine Zeile
				spec_id = lines[idx].strip().split(':', 1)[1].strip()
				# ~ results.append(f"SPEC_ID: {spec_id}")
				idx += 1

			elif line.startswith('$SPEC_REM:'):
				# SPEC_REM ist ein mehrzeiliger Abschnitt
				rem_lines = []
				idx += 1
				while idx < total_lines and not lines[idx].strip().startswith('$'):
					rem_lines.append(lines[idx].strip())
					idx += 1
				results.append("SPEC_REM:")
				results.extend(rem_lines)

			elif line.startswith('$DATE_MEA:'):
				# DATE_MEA hat eine Zeile
				date_mea = lines[idx].strip().split(':', 1)[1].strip()
				# ~ results.append(f"DATE_MEA: {date_mea}")
				idx += 1

			elif line.startswith('$MEAS_TIM:'):
				# MEAS_TIM hat eine Zeile
				meas_tim = lines[idx].strip().split(':', 1)[1].strip()
				# ~ results.append(f"MEAS_TIM: {meas_tim}")
				idx += 1

			elif line.startswith('$PRESETS:'):
				# PRESETS ist ein mehrzeiliger Abschnitt
				presets_lines = []
				idx += 1
				while idx < total_lines and not lines[idx].strip().startswith('$'):
					# ~ presets_lines.append(lines[idx].strip())
					idx += 1
				# ~ results.append("PRESETS:")
				# ~ results.extend(presets_lines)

			elif line.startswith('$ENER_FIT:'):
				# ENER_FIT hat eine Zeile
				ener_fit = lines[idx].strip().split(':', 1)[1].strip()
				# ~ results.append(f"ENER_FIT: {ener_fit}")
				idx += 1

			elif line.startswith('$MCA_CAL:'):
				# MCA_CAL hat zwei Zeilen
				mca_cal_lines = []
				idx += 1
				for _ in range(2):
					if idx < total_lines and not lines[idx].strip().startswith('$'):
						mca_cal_lines.append(lines[idx].strip())
						idx += 1
				results.append("MCA_CAL:")
				results.extend(mca_cal_lines)

			elif line.startswith('$SHAPE_CAL:'):
				# SHAPE_CAL hat zwei Zeilen
				shape_cal_lines = []
				idx += 1
				for _ in range(2):
					if idx < total_lines and not lines[idx].strip().startswith('$'):
						shape_cal_lines.append(lines[idx].strip())
						idx += 1
				results.append("SHAPE_CAL:")
				results.extend(shape_cal_lines)

			else:
				# Überspringe unbekannte Marker
				idx += 1
		else:
			# Überspringe Zeilen, die nicht mit $ beginnen
			idx += 1

	# Ergebnisse zusammenführen
	final_result = "\n".join(results)
	return final_result

def is_utf8(filename):
	try:
		with open(filename, 'r', encoding='utf-8') as file:
			file.read()
		return True
	except UnicodeDecodeError:
		return False
	except:
		print("Exception while testing for utf8")




# Hauptfunktion
def main():
	
	global exportGPfile

		
	# ~ initial_file_path = sys.argv[1] if len(sys.argv) > 1 else None
	plo = gp()
	# GUI erstellen
	root = tk.Tk()
	root.title("spe processor and gnu plotter")
	
	
	def on_live_check():
		if (widgets_extra[0]["divliv_var"].get() == True):
			# ~ print("AN")
			ylabel_var.set("Countrate [1/s]")
		else:
			# ~ print("AUS")
			ylabel_var.set("Counts")
	
######PLACEHOLDER COMMENT#########
		
	def handle_dropdown_selection(selection):
		global exportGPfile
		if selection == "No automation":
			print("No automation selected. Just proceed!")
		elif selection == "Auto plot":
			print("Auto plot selected")
			if(widgets_extra[0]["outputradio"].get() in {"pdf","png"}):
				plotgo()
				sleep(14) #waiting for the process would be better, but cannot wait for gnuplot do i
				if os.path.exists(tmp_file):
					os.remove(tmp_file)
				sys.exit()
			else:
				plotgo()
		elif selection == "Auto gp-export":
			print("Auto gp-export selected") #
			exportGPfile = True
			export_gp()
			if os.path.exists(tmp_file):
				os.remove(tmp_file)
			sys.exit()
		elif selection == "Auto ROI count":
			print("Auto ROI count selected")
			calc_roi_raw(True)
			if os.path.exists(tmp_file):
				os.remove(tmp_file)
			sys.exit()
		elif selection == "Auto add":
			print("Auto add selected")
			add_spectra(True)
			if os.path.exists(tmp_file):
				os.remove(tmp_file)
			sys.exit()
		elif selection == "Auto subtract (>= 0)":
			print("Auto subtract selected")
			subtract_spectra(False, True)
			if os.path.exists(tmp_file):
				os.remove(tmp_file)
			sys.exit()
		elif selection == "Auto subtract (neg. allowed)":
			print("Auto subtract selected")
			subtract_spectra(True, True)
			if os.path.exists(tmp_file):
				os.remove(tmp_file)
			sys.exit()
		elif selection == "Auto spe-to-csv":
			print("Auto spe-to-csv selected")
			csv_export(True)
			if os.path.exists(tmp_file):
				os.remove(tmp_file)
			sys.exit()
		elif selection == "Auto to HDTV":
			print("Auto to HDTV selected")
			export_hdtv()
			if os.path.exists(tmp_file):
				os.remove(tmp_file)
			sys.exit()
		elif selection == "Auto to xlsx":
			print("Auto .xlsx selected")
			makeXlsx(True)
			if os.path.exists(tmp_file):
				os.remove(tmp_file)
			sys.exit()
		elif selection == "Auto metadata export":
			print("Auto metadata export selected")
			show_meta_data(True)
			if os.path.exists(tmp_file):
				os.remove(tmp_file)
			sys.exit()
	
	def validate_numeric(entry_widget):
		"""
		Validates the content of an Entry widget to ensure it contains only numeric input.
		Changes the text color to red if invalid, otherwise black.
		"""
		content = entry_widget.get()
		if content.isnumeric() or content == "":  # Allow only numeric input or empty input
			entry_widget.config(fg="black")
		else:
			entry_widget.config(fg="red")
	
	def is_float(entry_widget):
		value = entry_widget.get()
		try:
			float(value)
			entry_widget.config(fg="black")
		except ValueError:
			entry_widget.config(fg="red")
			if value == "":
				entry_widget.config(fg="black")
	
	def validate_input(entry_widget):
		"""
		Validates the content of an Entry widget.
		Changes the text color to red if invalid, otherwise black.
		"""
		try:
			# Versuche, den Inhalt als Zahl zu interpretieren
			value = float(entry_widget.get())
			if 0 <= value <= 1:
				entry_widget.config(fg="black")  # Gültige Eingabe
			else:
				entry_widget.config(fg="red")  # Zahl außerhalb des Bereichs
		except ValueError:
			entry_widget.config(fg="red")  # Ungültige Eingabe

	def sum_values_by_ranges(range_list, long_list):
		"""
		Addiert Werte aus long_list basierend auf den Bereichsangaben in range_list.
		
		:param range_list: Liste von Zahlenpaaren als Strings, z. B. ['185 195', '245 263']
		:param long_list: Liste von Zahlenwerten (oder Strings, die Zahlen darstellen).
		:return: Eine Liste mit Summen, entsprechend den Zahlenbereichen in range_list.
		"""
		result = []
		# Sicherstellen, dass long_list numerische Werte enthält
		numeric_list = [float(x) for x in long_list]  # Optional `float` oder `int` wählen
		for range_pair in range_list:
			start, end = map(int, range_pair.split())  # Zahlenpaare in start und end aufteilen
			result.append(int(sum(numeric_list[start:end + 1])))  # Bereich auswählen und addieren
		return result

	def create_and_save_string(roi_results, temp_list, roilist, filename, automatisch):
		"""
		Erstellt einen mehrzeiligen String aus zwei Listen und speichert ihn in einer Datei, wenn bestätigt.
		:param list1: Erste Liste mit Werten
		:param list2: Zweite Liste mit Werten
		:param filename: Dateiname, in dem der String gespeichert werden soll
		"""
		# ~ if len(list1) != len(list2):
			# ~ raise ValueError("Beide Listen müssen die gleiche Anzahl an Elementen enthalten.")

		# Mehrzeiligen String mit einer klassischen Schleife erstellen
		combined_string = ""
		calculated_string = ""
		say_string = ""
		say_string2 = ""
		livetdiv = 1
		# ~ if (widgets_extra[0]["divliv_var"].get() == True):
			# ~ livetdiv = 
			# ~ print(temp_list[0])
		for i in range(len(roi_results)):
			combined_string += f"{temp_list[i][1]}:"
			calculated_string += f"{temp_list[i][1]}:"
			say_string += f"{temp_list[i][1]}:"
			say_string2 += f"{temp_list[i][1]}:"
			if (widgets_extra[0]["divliv_var"].get() == True):
				livetdiv = temp_list[i][2].split()[0]
			# ~ print("calculated_string",calculated_string)
			# ~ print("combined_string",combined_string)
			roisum = []
			roisum2 = []
			for j in range(len(roi_results[i])):
				combined_string += f" ({roilist[i][j]})= {round(float(roi_results[i][j])/float(livetdiv),3)};"
				# ~ print(roi_results[i][j])
				calculated_string += f" ({roilist[i][j]})= {round(float(roi_results[i][j])/(float(eff_var.get())*float(livetdiv)),3)};"
				tResult1 = round(float(roi_results[i][j])/float(livetdiv),3)#efficiency corrected
				tResult2 = round(float(roi_results[i][j])/(float(eff_var.get())*float(livetdiv)),3)#efficiency corrected
				roisum.append(tResult1)
				roisum2.append(tResult2)
				
				say_string += f" ({roilist[i][j]})= {tResult1};"
				say_string2 += f" ({roilist[i][j]})= {tResult2};"
				

			combined_string += "; all= "
			calculated_string += "; all= "
			say_string += "; all= "
			say_string2 += "; all= "
			combined_string += str(sum(roisum))
			calculated_string += str(sum(roisum2))
			say_string += str(sum(roisum))
			say_string2 += str(sum(roisum2))
			combined_string += "\n"
			calculated_string += "\n"
			say_string += "\n"
			say_string2 += "\n"
			# ~ say_string = combined_string
			# ~ say_string2 = calculated_string
			divisionlt = ''
			if (widgets_extra[0]["divliv_var"].get() == True):
				divisionlt = 'Results have been divided by livetime\n'
			if not automatisch:
				messagebox.showinfo("Info", divisionlt + "Raw ROIs:\n" + say_string + "\n" + "Efficiency corrected ROIs:\n"  + say_string2)
			# ~ messagebox.showinfo("Info", "Raw ROIs:\n" + combined_string + "\n" + "Efficiency corrected ROIs:\n"  + calculated_string)
			say_string2 = ""
			say_string =""
		
	
		allroi_sum = 0
		for rlist in roi_results:
			allroi_sum += sum(rlist)	
		# MessageBox anzeigen
		if automatisch:
			response = True
		else:
			response = messagebox.askyesno("Save raw ROI counts?", f"Sum of all raw ROIs of all spectra is: {allroi_sum}!\nDo you want to save all the results in {filename}\n\n")
		if response:
			# Wenn "Ja" gewählt wurde
			# ~ print("RESPONSE=TRUE")
			with open(filename, "w") as file:
				file.write(divisionlt)
				file.write("\n")
				file.write("Raw ROI count:\n")
				file.write(combined_string.strip())
				file.write("\nSum of all raw ROIs from all files:\n")
				file.write(str(allroi_sum))				
				file.write("\n\nEfficiency/time correct ROI count:\n")
				file.write(calculated_string.strip())

			print(f"String erfolgreich in '{filename}' gespeichert.")

	def csv_export(automatisch = False):
		flnmlst = get_filenames()
		spedatalist=[]
		calcdatalist=[]
		# ~ for widget_set in widgets:
		print(flnmlst)
		
		def do_export():
			divlivt = ''
			if (widgets_extra[0]["divliv_var"].get() == True):
				divlivt = 'Countrate(efficiency-corrected)'
			for filen in flnmlst:
				spedatalist.append(parse_file(filen))
			for i,filenm in enumerate(flnmlst):
				dateiname = ensure_unique_filename(spedatalist[i][1] + '.csv')
				write_to_file(dateiname, "#" + str(spedatalist[i][0]) + ", live time: " + spedatalist[i][2].split()[0] + ", efficiency: " + eff_var.get() + ", calibration: " + str(spedatalist[i][7]) + "\n")# str(spedatalist[i][7]).split()[1] + " " + str(spedatalist[i][7]).split()[2] + " " + str(spedatalist[i][7]).split()[3] + "\n")
				write_to_file(dateiname, "#Channel Energy Counts Counts(efficiency-corrected) " + divlivt + "\n")
				print(spedatalist[i])
				koeff0 = 0
				koeff1 = 1
				koeff2 = 0
				try: 
					float(spedatalist[i][7][1].split()[1])
					koeff0 = (float(spedatalist[i][7][1].split()[0]))
					koeff1 = (float(spedatalist[i][7][1].split()[1]))
					try:
						koeff2 = (float(spedatalist[i][7][1].split()[2]))
					except:
						print("third calibration coefficient invalid!")
				except:
					try:
						koeff0 = (float(spedatalist[i][6].split()[0]))
						koeff1 = (float(spedatalist[i][6].split()[1]))
					except:
						print("Error: No number for calibration coefficients found")

				for j,counts in enumerate(spedatalist[i][9]):
					stri = ''
					stri += str(j) 
					stri += ' ' #koeff0 koeff1 koeff2 HERE
					# ~ stri += str(round(float(spedatalist[i][7][1].split()[0]) + j*float(spedatalist[i][7][1].split()[1]) + j*j*float(spedatalist[i][7][1].split()[2]),2))
					stri += str(round(koeff0 + j*koeff1 + j*j*koeff2,3))
					stri += ' '
					stri += spedatalist[i][9][j]
					stri += ' '
					stri += str(round(float(spedatalist[i][9][j]) / float(eff_var.get()),4))
					if (widgets_extra[0]["divliv_var"].get() == True):
						stri += ' '
						stri += str(round(float(spedatalist[i][9][j]) / (float(eff_var.get())*float(spedatalist[i][2].split()[0])),4))
						# ~ print(spedatalist[i][2].split()[0])
					stri += '\n'
					write_to_file(dateiname, stri)
		if not automatisch:
			if(ask_question("Export as tables","All provided spectra will be exported as .csv (or .xlsx) table (for Excel, Origin, etc.).\n (channel, energy, counts, efficiency/time corrected counts) \nThe output will be saved as <filename>.csv / .xlsx\nContinue?")):			
				do_export()
		else:
			do_export()

				
			# ~ spedatalist[i][9] #=counts from countlist
			# ~ spedatalist[i][1] #=basename file
		# ~ print('flnmlst')
		# ~ print(flnmlst)
		# ~ print('spedatalist')
		# ~ print(spedatalist)
		# ~ for i,filenm in enumerate(flnmlst):
			# ~ tmp_list = parse_file(filenm)
			# ~ dataonly.append(tmp_list[9])
		#str(float(spedatalist[i][7][1].split()[0])) + '+' + str(float(spedatalist[i][7][1].split()[1])) + '*$0+' + str(float(spedatalist[i][7][1].split()[2])) + '*$0**2)'

	def update_textfield(event):
		selected_value = plotway_var.get()  # Ausgewählten Wert abrufen
		if "channels" in selected_value:
			xlabel_var.set("Channel")
		elif "energy" in selected_value:
			xlabel_var.set("Energy [keV]")

	def show_meta_data(automatisch = False):
		combined_string = ""
		roilist=[]
		flnmlst = get_filenames()
		# ~ spedatalist=[]
		# ~ calcdatalist=[]
		#for widget_set in widgets:
		# ~ print(flnmlst)
		countlist = []
		fulllive = []
		fullreal = []
		deadtime = 0
		deadtimep = []
		for filen in flnmlst:
			roilist.append(parse_and_merge_intervals(find_roi(filen)))		
		for filen in flnmlst:
			# ~ print(get_file_metadata_string(filen))
			parsed_file = parse_file(filen)
			info_string = ''
			# ~ print(parse_text_file(filen))
			prefixes = ["SPEC_ID: ", " PRESETS: ", "", " ENER_FIT: "]
			# ~ print(process_nested_list(parse_meta(filen),prefixes).replace("Live Time", "Live Time "))
			combined_string += "Name: "
			combined_string += str(parsed_file[1])
			combined_string += "\n"
			combined_string += get_file_metadata_string(filen)
			combined_string += "\nchannels: "
			combined_string += str(len(parsed_file[9]))
			combined_string += "\nall counts: "
			combined_string += str(int(sum([float(num) for num in parsed_file[9]])))
			combined_string += "\nDATE_MEAS: "
			combined_string += parsed_file[10][7]
			combined_string += "\n"
			combined_string += parse_text_file(filen)
			# ~ print("parse_text_file(filen)")
			# ~ print(parse_text_file(filen))
			# ~ print("parse_file(filen)")
			print(parsed_file)
			# ~ print(parse_file(filen))
			combined_string += " "
			combined_string += "\nROIS: "
			for ele in roilist[0]:
				combined_string += str(ele)
				combined_string += " "
			combined_string += "\n"
			combined_string += process_nested_list(parse_meta(filen),prefixes).replace("Live Time", "Live Time ")
			combined_string += "\n"
			combined_string += "MEAS_TIM:"
			combined_string += "live:"
			combined_string += parsed_file[10][9].split()[0]
			fulllive.append(int(parsed_file[10][9].split()[0]))
			combined_string += " real:"
			fullreal.append(int(parsed_file[10][9].split()[1]))
			combined_string += parsed_file[10][9].split()[1]
			combined_string += "\ndead:"
			combined_string += str(int(parsed_file[10][9].split()[1]) - int(parsed_file[10][9].split()[0]))
			combined_string += " average-dead%:"
			combined_string += str(round(100*(float(parsed_file[10][9].split()[1]) - float(parsed_file[10][9].split()[0]))/float(parsed_file[10][9].split()[1]),3))
			combined_string += "\n"
			combined_string += "\n"
			
			info_string += "Name: "
			info_string += str(parse_file(filen)[1])
			info_string += " \n"
			info_string += get_file_metadata_string(filen)
			info_string += " channels: "
			info_string += str(len(parsed_file[9]))
			info_string += " all counts: "
			info_string += str(int(sum([float(num) for num in parsed_file[9]])))
			countlist.append(int(sum([float(num) for num in parsed_file[9]])))
			info_string += " DATE_MEAS: "
			info_string += parsed_file[10][7]
			info_string += " "
			info_string += parse_text_file(filen)
			info_string += " "
			# ~ info_string += parse_text_file(filen)
			# ~ info_string += " "
			info_string += " ROIS: "
			for ele in roilist[0]:
				info_string += str(ele)
				info_string += ", "
			info_string += process_nested_list(parse_meta(filen),prefixes).replace("Live Time", "Live Time ")
			info_string += " "
			info_string += "MEAS_TIM:"
			info_string += "live:"
			info_string += parsed_file[10][9].split()[0]
			info_string += " real:"
			info_string += parsed_file[10][9].split()[1]
			info_string += " dead: "
			info_string += str(int(parsed_file[10][9].split()[1]) - int(parsed_file[10][9].split()[0]))
			deadtime += (int(parsed_file[10][9].split()[1]) - int(parsed_file[10][9].split()[0]))
			info_string += " average-dead%: "
			info_string += str(round(100*(float(parsed_file[10][9].split()[1]) - float(parsed_file[10][9].split()[0]))/float(parsed_file[10][9].split()[1]),3))
			deadtimep.append(round(100*(float(parsed_file[10][9].split()[1]) - float(parsed_file[10][9].split()[0]))/float(parsed_file[10][9].split()[1]),4))
			info_string += "\n"
			if not automatisch:
				messagebox.showinfo("See the metadata below!", info_string)
		# ~ print(combined_string)
		output_name = widgets_extra[0]["outputname"].get() + ".txt"
		unique_output_name = ensure_unique_filename(output_name)
		deadtimep_avg = sum(deadtimep)/len(deadtimep)
		print(deadtimep_avg)
		allcounts = sum(countlist)
		print(allcounts)
		if automatisch:
			response = True
		else:
			response = messagebox.askyesno("Save metadata to file?", f"All counts together: {allcounts}\nSummed up livetime: {sum(fulllive)} Summed up realtime: {sum(fullreal)} Overall deadtime: {deadtime}\nAverage deadtime %: {deadtimep_avg}\nMetadata looks good?\nDo you want to save the results in {unique_output_name}?")#"\n\n{combined_string.strip()}")
		filename = unique_output_name
		if response:
			# Wenn "Ja" gewählt wurde
			with open(filename, "w") as file:
				file.write("\n")
				file.write(combined_string.strip())
				file.write("\nAll counts together:\n")
				file.write(str(allcounts))
				file.write("\nSummed up livetime:\n")
				file.write(str(sum(fulllive)))
				file.write("\nSummed up realtime:\n")
				file.write(str(sum(fullreal)))
				file.write("\nOverall deadtime:\n")
				file.write(str(deadtime))
				file.write("\nAverage overall deadtime %:")
				file.write(str(deadtimep_avg))
			print(f"String erfolgreich in '{filename}' gespeichert.")
			# ~ spedatalist.append(parse_file(filen))
		# ~ for i,filenm in enumerate(flnmlst):
			# ~ dateiname = ensure_unique_filename(spedatalist[i][1] + '.csv')		
		
	def calc_roi_raw(automatisch = False):
		flnmlst = get_filenames()
		output_name = widgets_extra[0]["outputname"].get() + ".txt"
		unique_output_name = ensure_unique_filename(output_name)
		# ~ temp_list = parse_file(filenm)
		roilist=[]
		temp_list=[]
		roi_results = []
		for i,filenm in enumerate(flnmlst):  # Für jede Datei
			roilist.append(parse_and_merge_intervals(find_roi(filenm)))
			temp_list.append(parse_file(filenm))
			roi_results.append(sum_values_by_ranges(roilist[i],temp_list[i][9]))
			
		print("roi_results:")
		print(roi_results)
		create_and_save_string(roi_results, temp_list, roilist, unique_output_name, automatisch)	
		# ~ print(temp_list)
		# ~ sleep(1)
		print("roilist:")
		print(roilist)
		print("temp_list:")
		print(temp_list)
	def export_csv():
		flnmlst = get_filenames()
		output_name = widgets_extra[0]["outputname"].get() + ".txt"
		unique_output_name = ensure_unique_filename(output_name)
		# ~ temp_list = parse_file(filenm)
		roilist=[]
		temp_list=[]
		roi_results = []
		for i,filenm in enumerate(flnmlst):  # Für jede Datei
			roilist.append(parse_and_merge_intervals(find_roi(filenm)))
			temp_list.append(parse_file(filenm))
			roi_results.append(sum_values_by_ranges(roilist[i],temp_list[i][9]))
		
		print(roi_results)
		create_and_save_string(roi_results, temp_list, roilist, unique_output_name)	
		# ~ print(temp_list)
		# ~ print(roilist)

	def makeXlsx(automatisch=False):
		flnmlst = get_filenames()
		spedatalist=[]
		namelist=[]
		for filen in flnmlst:
			spedatalist.append(parse_file(filen))
		for i,filenm in enumerate(flnmlst):
			namelist.append(ensure_unique_filename(spedatalist[i][1] + '.csv'))
		if automatisch:
			csv_export(True)
		else:
			csv_export(False)
		# ~ csv_export(True)
		for fname in namelist:
			csv_to_xlsx(fname,ensure_unique_filename(os.path.splitext(fname)[0]+'.xlsx'))
			if os.path.exists(fname):
				os.remove(fname)
	

	def get_filenames():
		filenamelist=[]
		for widget_set in widgets:
			if widget_set['file_path_var'].get():
				filenamelist.append(widget_set['file_path_var'].get())		
		return filenamelist
		
	def add_spectra(automatisch = False):
		global livet,realt
		print("Adding spectra to desired output:")
		# ~ print(parse_and_merge_intervals(find_roi('Tc08.Spe')))
		# ~ print(get_filenames())
		roilist=[]
		roilist_clean=[]
		flnmlst = get_filenames()
		countlist = []
		# ~ timelist = [[0] * 2 for _ in range(len(flnmlst))]
		timelist = []
		output_name = widgets_extra[0]["outputname"].get() + ".spe"
		unique_output_name = ensure_unique_filename(output_name)
		# ~ print(f"Final unique filename: {unique_output_name}")
		
		if len(flnmlst) < 2: #for addition more than one needed
			print("Error! More spectra needed!")
		# ~ for filenm in flnmlst: #prozessiere jeden dateinamen
			# ~ temp_list = parse_file(filenm)
			# ~ chn_nmb = temp_list[3].split()
			# ~ for i in range(0,len(temp_list[9])):
				# ~ print(temp_list[9][i])
		else:
			# ~ cts = []
			for filenm in flnmlst:  # Für jede Datei
				roilist.append(parse_and_merge_intervals(find_roi(filenm)))
				temp_list = parse_file(filenm)
				# ~ print(temp_list)
				# Wenn countlist leer ist, initialisiere sie mit Nullen entsprechend der Länge von temp_list[9]
				if not countlist:
					countlist = [0] * len(temp_list[9])
				# ~ if not timelist:
					# ~ timelist = [0] * 2 #len(temp_list[2].split())
				
				# ~ cts.append(temp_list[9])
				# ~ print(cts)
				# ~ print("CCCCCCCCCCCTTTTTTTTTTSSSSSSSSSSSS")
				
				# Werte von temp_list[9] in countlist aufsummieren
				for i in range(len(temp_list[9])):
					countlist[i] += int(temp_list[9][i]) 
				# ~ for i in range(2):
					# ~ timelist[i] += int(temp_list[2][i]) 
				timelist.append(temp_list[2].split())
				for j in range(len(timelist)):
					livet += int(timelist[j][0])
					realt += int(timelist[j][1])
			# ~ plo.save(cts, tmp_file)
			roilist_clean = parse_and_merge_intervals(list(itertools.chain.from_iterable(roilist)))			
			temp_list[11] = prepend_roi_list(roilist_clean) + trim_roi_list(temp_list[11])
			temp_list[10][3] = str(temp_list[10][3]) + " (summed spectrum)"
			if not automatisch:
				if(ask_question("Subtracting spectra","All provided spectra will be added together. Measurement durations will be summed up also. The output (summed spectrum) will be saved as " + unique_output_name + "\nContinue?")):
					save_output_file(unique_output_name, temp_list, countlist)
			else:	
				save_output_file(unique_output_name, temp_list, countlist)
			livet = 0
			realt = 0
			# ~ for i in range(len(roilist)):
			# ~ print(countlist)
			# ~ print(temp_list)
			# ~ print(roilist)
			# ~ print(roilist_clean)
			# ~ print("TEMPLISTHIER")
			# ~ print(temp_list[11])
			# ~ print("sauber:?")
			# ~ print(prepend_roi_list(roilist_clean) + trim_roi_list(temp_list[11]))

			# ~ modify_list_of_lists(temp_list,roilist_clean)
			# ~ print(temp_list)
			# ~ print(timelist)
			# ~ print(livet)
			# ~ print(realt)
		
		# ~ print("Summierte Werte:", countlist)				
			# ~ print(chn_nmb[1])
			# ~ print("nun erstes element:")
			# ~ print(temp_list)
			# ~ print(parse_file(filenm))
			# ~ print(len(temp_list[9]))
			# ~ temp_list
			
			
			
	def subtract_spectra(subzero = False, automatisch = False):
		# ~ ask_question()
		global livet,realt
		print("Subtracting spectra to desired output:")
		# ~ print(get_filenames())
		flnmlst = get_filenames()
		countlist = []		
		roilist=[]
		roilist_clean=[]
		# ~ timelist = [[0] * 2 for _ in range(len(flnmlst))]
		timelist = []
		output_name = widgets_extra[0]["outputname"].get() + ".spe"
		unique_output_name = ensure_unique_filename(output_name)
		# ~ print(f"Final unique filename: {unique_output_name}")

		
		if len(flnmlst) < 2: #for addition more than one needed
			print("Error! More spectra needed!")
		# ~ for filenm in flnmlst: #prozessiere jeden dateinamen
			# ~ temp_list = parse_file(filenm)
			# ~ chn_nmb = temp_list[3].split()
			# ~ for i in range(0,len(temp_list[9])):
				# ~ print(temp_list[9][i])
		else:
			# ~ cts = []

			ratiolist = []
			
			for filenm in flnmlst:  # Für jede Datei
				roilist.append(parse_and_merge_intervals(find_roi(filenm)))
				temp_list = parse_file(filenm)
				timelist.append(temp_list[2].split()[0])
				
			timelist_int = list(map(int, timelist))
			# Index der kleinsten Zahl
			min_index = timelist_int.index(min(timelist_int))
			# Index der größten Zahl
			max_index = timelist_int.index(max(timelist_int))
			
			
			livet = timelist[min_index]
			realt = timelist[min_index] #wrong, but really obviously wrong, calcultions with realtime is not zielfuehrend
			
			for i,filenm in enumerate(flnmlst):  # Für jede Datei
				
				ratiolist.append(float(timelist[min_index])/float(timelist[i]))			
			
			countlist = parse_file(flnmlst[0])[9]
			for n,element in enumerate(countlist):
				countlist[n] = float(countlist[n])*ratiolist[0]
				
			for k,filenm in enumerate(flnmlst):  # Für jede Datei
				
				if (k>0):
					temp_list = parse_file(filenm)
					for i in range(len(temp_list[9])):
						countlist[i] = int(round(float(countlist[i]) - float(temp_list[9][i])*ratiolist[k], 0))			
			# ~ countlist=check_and_handle_negatives(countlist)	
		
		roilist_clean = parse_and_merge_intervals(list(itertools.chain.from_iterable(roilist)))			
		temp_list[11] = prepend_roi_list(roilist_clean) + trim_roi_list(temp_list[11])
		temp_list[10][3] = str(temp_list[10][3]) + " (subtracted spectrum)"
		
		if not automatisch:	
			if(ask_question("Subtracting spectra","The first provided file will be the template, from which all other provided spectra will be subtracted. If livetimes are different, then all counts are normalized to shortest duration, subtracted and rounded afterwards. The output will be saved as " + unique_output_name + "\nContinue?")):
				countlist=check_and_handle_negatives(countlist,automatisch,subzero)
				save_output_file(unique_output_name, temp_list, countlist)
		else:
			countlist=check_and_handle_negatives(countlist,automatisch,subzero)
			save_output_file(unique_output_name, temp_list, countlist)
			
		livet = 0
		realt = 0
		print(temp_list[11])	

	# ~ def update_checkbox_text_color(event):
		# ~ selected_value = plotstyle_var.get()  # Ausgewählten Wert des Dropdown-Menüs abrufen
		# ~ if selected_value in {"Standard filled", "Steps"}:
			# ~ checkbox.config(fg="red")  # Schriftfarbe auf Rot setzen
		# ~ else:
			# ~ checkbox.config(fg="black")  # Schriftfarbe auf Schwarz zurücksetzen

	def update_checkbox_text_color(event):
		# Nur prüfen, wenn das Kontrollkästchen aktiviert ist
		if roi_var.get() and plotstyle_var.get() in {"Standard filled", "Steps"}:
			checkbox.config(fg="red")  # Schriftfarbe auf Rot setzen
		else:
			checkbox.config(fg="black")  # Schriftfarbe auf Schwarz setzen

	def toggle_checkbox(*args):
		# Aktualisiere die Schriftfarbe basierend auf der ROI-Auswahl
		update_checkbox_text_color(None)
	
	
	def export_gp():
		global tmp_file
		global exportGPfile
		exportGPfile=True
		print("Exporting .gp in current working directory")
		# ~ print(plotgo())
		gpoutput_name = widgets_extra[0]["outputname"].get() + ".gp"
		unique_output_name = ensure_unique_filename(gpoutput_name)
		gpoutput_data = widgets_extra[0]["outputname"].get() + ".csv"
		unique_data_file = ensure_unique_filename(gpoutput_data)
		tmp_file = unique_data_file
		try:
			with open(unique_output_name, "w") as file:
				for line in plotgo():
					# ~ print(line)
					file.write(line + '\n')

		except Exception as e:
			print(f"An error occurred while writing the file: {e}")
		exportGPfile = False
		tmp_file = "tmp.dat"
	
	def export_hdtv():
		flnmlst = get_filenames()
		spedatalist=[]
		dataonly = []		
		koeff0 = '0'
		koeff1 = '1'
		koeff2 = '0'	
			
		for i,spefile in enumerate(flnmlst):
		# ~ for i,widget_set in enumerate(widgets):
			try:
				spedatalist.append(parse_file(spefile))
			except:
				pass
		for i,flist in enumerate(spedatalist):
			spedatalist[i].append(ensure_unique_filename(spedatalist[i][0] + '-hdtv.spc_cal'))	
			flist.append(ensure_unique_filename(spedatalist[i][0] + '-hdtv.spc_cal'))
			# ~ print("ALLNAMES")	
			print(ensure_unique_filename(spedatalist[i][0] + '-hdtv.spc_cal'))	
			
			try: 
				float(spedatalist[i][7][1].split()[1])
				koeff0 = str(float(spedatalist[i][7][1].split()[0]))
				koeff1 = str(float(spedatalist[i][7][1].split()[1]))
				try:
					koeff2 = str(float(spedatalist[i][7][1].split()[2]))
				except:
					print("third calibration coefficient invalid!")
			except:
				try:
					koeff0 = str(float(spedatalist[i][6].split()[0]))
					koeff1 = str(float(spedatalist[i][6].split()[1]))
				except:
					print("Error: No number for calibration coefficients found")
			# ~ print(len(flist[i]))
			spedatalist[i].append(str(os.path.basename(spedatalist[i][-1])) + ': ' + koeff0 + '   ' + koeff1 + '   ' + koeff2)
			
			
			# ~ print(str(flist[-1]) + ': ' + koeff0 + '   ' + koeff1 + '   ' + koeff2)
			print("str(spedatalist[i][-1])")
			print(str(spedatalist[i][-1]))
			print("str(spedatalist[i][-2])")
			print(str(spedatalist[i][-2]))
			# ~ print("VORHER -2 davor -1")
			# ~ with open(spedatalist[i][-1], "a") as file:
				# ~ file.write(str(flist[-1]) + ': ' + koeff0 + '   ' + koeff1 + '   ' + koeff2)
		try:
			for i,element in enumerate(spedatalist):
				with open(element[-2], "a") as file:
					for x in spedatalist:
						file.write(x[-1]) #write all calibrations
						file.write('\n')
				# ~ print(spedatalist)
				# ~ print("FILENAMEs")
				# ~ print(spedatalist[i][0] + '-hdtv.spc')
				# ~ print(spedatalist[i][0] + '-hdtv.spc')
				with open(ensure_unique_filename(spedatalist[i][0] + '-hdtv.spc'), "a") as file:
					for j,unele in enumerate(spedatalist[i][9]):
						file.write(str(spedatalist[i][9][j])) #write data per spectrum
						file.write('\n')
			export_hdtv_button.config(fg="#00ff00")
			export_hdtv_button.config(text="HDTV-Export again?")
		except:
			export_hdtv_button.config(fg="#ff0000")
		# ~ sleep(1)
		# ~ export_hdtv_button.config(bg="#BFBFBF")
		# ~ print("spedatalist")
		# ~ print(spedatalist)
		# ~ print(len(spedatalist[1]))
		
		
			
	def plotgo():
		try:
			return try_plotgo()
		except BrokenPipeError:
			messagebox.showinfo("Broken Pipe Error", "Gnuplot crashed \n Please restart this software")
		except Exception as e:
			error_message = traceback.format_exc()  # Stacktrace als String speichern
			messagebox.showerror("Unexpected Error", f"An unexpected error occurred:\n{error_message}")
			# ~ return try_plotgo()
		# ~ except BrokenPipeError:
			# ~ messagebox.showinfo("Broken Pipe Error","Gnuplot crashed \n Please restart this software")
		# ~ except:
			
	def try_plotgo():
		# ~ print(parse_and_merge_intervals(find_roi('Tc08.Spe')))
		efficy = validate_efficy(eff_var)
		gpc_indices = []
		plotlines = []
		gp_commands = []
		spedatalist=[]
		# ~ mylist=[]
		roilist=[]
		roilist_clean=[]
		dataonly = []
		flnmlst = get_filenames()
		plottingstyle = 'lines'
		dashtype = '1'
		channelsonlystring = 'column(0)'
		usingstring=''
		

		for widget_set in widgets:
			spedatalist.append(parse_file(widget_set['file_path_var'].get()))

		#["Standard", "Standard filled", "Steps", "Filled steps", "Impulses", "Surprise"]
		if (widgets_extra[0]["plotstyle"].get() == "Standard"):
			plottingstyle = 'lines'
		elif (widgets_extra[0]["plotstyle"].get() == "Standard filled"):
			plottingstyle = 'filledcurves'
		elif (widgets_extra[0]["plotstyle"].get() == "Steps"):
			plottingstyle = 'histeps'
		elif (widgets_extra[0]["plotstyle"].get() == "Filled steps"):
			plottingstyle = 'fillsteps'
			# ~ gp_commands.append('set style fill solid 0.5')
		elif (widgets_extra[0]["plotstyle"].get() == "Impulses"):
			plottingstyle = 'impulses'
		elif (widgets_extra[0]["plotstyle"].get() == "Surprise"):
			styles = ["dots", "points", "boxes", "linespoints", "ellipses", "circles"]
			plottingstyle = random.choice(styles)
			# ~ plottingstyle = 'ellipses'
		new_list=[]	
		for i,filenm in enumerate(flnmlst):
			print(spedatalist[i])
			tmp_list = parse_file(filenm)
			# ~ dataonly.append(tmp_list[9])
			if (widgets_extra[0]["divliv_var"].get() == True):
				# ~ print(tmp_list[2].split()[0])
				# ~ print("GERADE EBEN")
				dataonly.append(divide_list_by_livetime(tmp_list[9],int(tmp_list[2].split()[0])))
			else:
				dataonly.append(tmp_list[9])
			# ~ new_list.append(divide_list_by_efficy(dataonly[i], efficy))
		# ~ livetimediv = 1
		# ~ if (widgets_extra[0]["divliv_var"].get() == True):
			
		ergeb = divide_nested_lists_by_efficy(dataonly,efficy)
		dataonly = ergeb
		
		for i,element in enumerate(dataonly): #add the plot offset from advanced settings
			dataonly[i] = add_to_list_elements(element,float(config2[0]["offset_var"])*i)
		
		# ~ print(dataonly)
		# ~ print(dataonly)
		# ~ print(ergeb)
		
		# ~ dataonly = new_list
		# ~ new_list = divide_list_by_efficy(dataonly, efficy)
		def get_gnuplot_command(selection):
			match selection:
				case "top left in":
					return "set key inside top left"
				case "top right in":
					return "set key inside top right"
				case "top center in":
					return "set key inside top center"
				case "top center in horiz":
					return "set key inside top center horizontal"
				case "bottom left in":
					return "set key inside bottom left"
				case "bottom right in":
					return "set key inside bottom right"
				case "left in":
					return "set key inside left"
				case "right in":
					return "set key inside right"
				case "center in":
					return "set key inside center"
				case "top left out":
					return "set key outside top left"
				case "top center out":
					return "set key outside top center"
				case "top center out horiz":
					return "set key outside top center horizontal"
				case "bottom left out":
					return "set key outside bottom left"
				case "bottom right out":
					return "set key outside bottom right"
				case "bottom center out":
					return "set key outside bottom center"
				case "outside left":
					return "set key outside left"
				case "outside right":
					return "set key outside right"
				case _:
					return "# Invalid selection"
						
		def make_plotlines(channelja):
			
			xoffset = config2[0]["xoffset_var"]	
			koeff0 = '0'
			koeff1 = '1'
			koeff2 = '0'
			
			for filenm in flnmlst:
				roilist.append(parse_and_merge_intervals(find_roi(filenm)))
			roilist_clean = parse_and_merge_intervals(list(itertools.chain.from_iterable(roilist)))	
			for i,filenm in enumerate(flnmlst):
				# ~ tmp_list = parse_file(filenm)
				# ~ dataonly.append(tmp_list[9])
				#["line", "dashed", "dotted", "dashdotted", "dotdotdashed"]
				if (widgets[i]['dropdown_var'].get() == 'line'):
					dashtype = '1'
				if (widgets[i]['dropdown_var'].get() == 'dashed'):
					dashtype = '2'
				if (widgets[i]['dropdown_var'].get() == 'dotted'):
					dashtype = '3'
				if (widgets[i]['dropdown_var'].get() == 'dashdotted'):
					dashtype = '4'
				if (widgets[i]['dropdown_var'].get() == 'dotdotdashed'):
					dashtype = '5'
				if channelja:
					if(widgets_extra[0]["displayroi"].get() == True):
						for j,roi in enumerate(roilist[i]):
							# ~ print(roilist[i][j].split()[0],roilist[i][j].split()[1])
							plotlines.append('"' + tmp_file + '" using ((($0 >= ' + roilist[i][j].split()[0] + ' && $0 <= ' + roilist[i][j].split()[1] + ') ? (' + '0' + '+' + '1' + '*$0+' + '0' + '*$0**2 + ' + str(float(xoffset) * (i)) + ') : 1/0)):(($0 >= ' + roilist[i][j].split()[0] + ' && $0 <= ' + roilist[i][j].split()[1] + ') ? $' + str(i+1) + '/' + str(efficy) + ' : 1/0)' + ' with ' + plottingstyle + ' linecolor rgb "' + roi_color_button.cget("bg") + '" dashtype ' + dashtype + ' title ""')
							
						usingstring = '(('
						if not roilist[i] or not len(roilist[i]) % 2 ==0:
							usingstring += '($0 < 0 && $0 > '
							usingstring += str(len(parse_file(filenm)[9]))
							usingstring += ')'
						else:
							for k,elem in enumerate(roilist[i]):
								usingstring += '($0 > '
								usingstring += elem.split()[0]
								usingstring += ' && $0 < '
								usingstring += elem.split()[1]
								usingstring += ')'
								if k<len(roilist[i])-1:
									usingstring += ' || '
						usingstring += ') ? 1/0 : $0 + ' + str(float(xoffset) * (i)) + ')'	
						plotlines.append('"' + tmp_file + '" using (' + usingstring + '):($' + str(i+1) + '/' + str(efficy) + ') with ' + plottingstyle + ' linecolor rgb "' + widgets[i]['button_color_var'].get() + '" dashtype ' + dashtype + ' title "' + widgets[i]['small_text_var'].get() + '"')
						# ~ plotlines.append('"' + tmp_file + '" using (' + usingstring + '):($1' + '/' + str(efficy) + ') with ' + plottingstyle + ' linecolor rgb "' + widgets[i]['button_color_var'].get() + '" dashtype ' + dashtype + ' title "' + widgets[i]['small_text_var'].get() + '"')
						gpc_indices.append(len(plotlines))
						# ~ plotlines.append('endfile') #SURE ABOUT THIS?
								
					else:
						plotlines.append('"' + tmp_file + '" using (' + channelsonlystring + '):($' + str(i+1) +'/'+ str(efficy) + ') with ' + plottingstyle + ' linecolor rgb "' + widgets[i]['button_color_var'].get() + '" dashtype ' + dashtype + ' title "' + widgets[i]['small_text_var'].get() + '"')
						gpc_indices.append(len(plotlines))
				else: #also channel=nein; energy = ja
					try: 
						float(spedatalist[i][7][1].split()[1])
						koeff0 = str(float(spedatalist[i][7][1].split()[0]))
						koeff1 = str(float(spedatalist[i][7][1].split()[1]))
						try:
							koeff2 = str(float(spedatalist[i][7][1].split()[2]))
						except:
							print("third calibration coefficient invalid!")
					except:
						try:
							koeff0 = str(float(spedatalist[i][6].split()[0]))
							koeff1 = str(float(spedatalist[i][6].split()[1]))
						except:
							print("Error: No number for calibration coefficients found")
					if(widgets_extra[0]["displayroi"].get() == True):
						# ~ print(str(spedatalist[i][7][1].split()[0]).isnumeric())
						# ~ print(str(spedatalist[i][7][1].split()))

						for j,roi in enumerate(roilist[i]):
							# ~ print(roilist[i][j].split()[0],roilist[i][j].split()[1])
							plotlines.append('"' + tmp_file + '" using ((($0 >= ' + roilist[i][j].split()[0] + ' && $0 <= ' + roilist[i][j].split()[1] + ') ? (' + koeff0 + '+' + koeff1 + '*$0+' + koeff2 + '*$0**2 + ' + str(float(xoffset) * (i)) + ') : 1/0)):(($0 >= ' + roilist[i][j].split()[0] + ' && $0 <= ' + roilist[i][j].split()[1] + ') ? ($' + str(i+1) + '/' + str(efficy) + ') : 1/0)' + ' with ' + plottingstyle + ' linecolor rgb "' + roi_color_button.cget("bg") + '" dashtype ' + dashtype + ' title ""')
						
						usingstring = '(('
						if not roilist[i] or not len(roilist[i]) % 2 ==0:
							usingstring += '($0 < 0 && $0 > '
							usingstring += str(len(parse_file(filenm)[9]))
							usingstring += ')'
						else:
							for k,elem in enumerate(roilist[i]):
								usingstring += '($0 > '
								usingstring += elem.split()[0]
								usingstring += ' && $0 < '
								usingstring += elem.split()[1]
								usingstring += ')'
								if k<len(roilist[i])-1:
									usingstring += ' || '
						usingstring += ') ? 1/0 :('	
						usingstring += koeff0 + '+' + koeff1 + '*$0+' + koeff2 + '*$0**2 + ' + str(float(xoffset) * (i)) + ')'	
						usingstring += '))'	
						plotlines.append('"' + tmp_file + '" using (' + usingstring + ':($' + str(i+1) + '/' + str(efficy) + ')' + ' with ' + plottingstyle + ' linecolor rgb "' + widgets[i]['button_color_var'].get() + '" dashtype ' + dashtype + ' title "' + widgets[i]['small_text_var'].get() + '"')
						# ~ plotlines.append('"' + tmp_file + '" using (' + usingstring + ':($1' + '/' + str(efficy) + ')' + ' with ' + plottingstyle + ' linecolor rgb "' + widgets[i]['button_color_var'].get() + '" dashtype ' + dashtype + ' title "' + widgets[i]['small_text_var'].get() + '"')
						gpc_indices.append(len(plotlines))
			
			# ~ ent	fer	ne	plotlines.append('"' + tmp_file + '" using (' + str(float(spedatalist[i][7][1].split()[0])) + '+' + str(float(spedatalist[i][7][1].split()[1])) + '*column(0)+' + str(float(spedatalist[i][7][1].split()[2])) + '*column(0)**2):' + str(i+1) + ' with ' + plottingstyle + ' linecolor rgb "' + widgets[i]['button_color_var'].get() + '" dashtype ' + dashtype + ' title "' + widgets[i]['small_text_var'].get() + '"')
					else:	
						plotlines.append('"' + tmp_file + '" using (' + koeff0 + '+' + koeff1 + '*column(0)+' + koeff2 + '*column(0)**2 + ' + str(float(xoffset) * (i)) + '):($' + str(i+1) + '/' + str(efficy) + ')' + ' with ' + plottingstyle + ' linecolor rgb "' + widgets[i]['button_color_var'].get() + '" dashtype ' + dashtype + ' title "' + widgets[i]['small_text_var'].get() + '"')
						# ~ plotlines.append('"' + tmp_file + '" using (' + koeff0 + '+' + koeff1 + '*column(0)+' + koeff2 + '*column(0)**2 + ' + str(float(xoffset) * (i)) + '):($1' + '/' + str(efficy) + ')' + ' with ' + plottingstyle + ' linecolor rgb "' + widgets[i]['button_color_var'].get() + '" dashtype ' + dashtype + ' title "' + widgets[i]['small_text_var'].get() + '"')
						gpc_indices.append(len(plotlines))
			usingstring=''
			print(plotlines)
			
		
		if ('Single' in widgets_extra[0]["plotway"].get()): #falls multiple findet sich weiter unten beim plot-cmd
			if(widgets_extra[0]["outputradio"].get()=="png"):
				gp_commands.append("set terminal pngcairo size 800,600 enhanced")
				gp_commands.append('set output "' + ensure_unique_filename(widgets_extra[0]["outputname"].get() + '.png') + '"')
			elif(widgets_extra[0]["outputradio"].get()=="pdf"):
				gp_commands.append("set terminal pdf")
				gp_commands.append('set output "' + ensure_unique_filename(widgets_extra[0]["outputname"].get() + '.pdf') + '"')
			elif(widgets_extra[0]["outputradio"].get()=="interactive window"):
				gp_commands.append("set terminal wxt")
				# ~ gp_commands.append("set terminal qt")

		
		# ~ if (widgets_extra[0]["transparentcheck"].get() == True):
		# ~ if(trans_var.get() != ""):
			# ~ try:
				# ~ gp_commands.append('set style fill transparent solid ' + str(1-round(float(trans_var.get())-math.floor(float(trans_var.get())),2)) + ' noborder') #TRANSPARENCYYYYY
			# ~ except:
				# ~ print("FEHLERTRANSPARENZEINGABE")
		if(config2[0]["transparency"] != ""):
			# ~ print(round(1-float(trans_var.get()),2))
			# ~ print(str(round(1-float(trans_var.get())-math.floor(float(trans_var.get())),2)))#1-(float(trans_var.get())-math.floor(float(trans_var.get())))
			try:
				gp_commands.append('set style fill transparent solid ' + str(1-round(float(config2[0]["transparency"])-math.floor(float(config2[0]["transparency"])),2)) + ' noborder') #TRANSPARENCYYYYY
			except:
				print("FEHLERTRANSPARENZEINGABE")
		if(title_var.get() != "" or title_var.get() != " "):
			# ~ print(round(1-float(trans_var.get()),2))
			# ~ print(str(round(1-float(trans_var.get())-math.floor(float(trans_var.get())),2)))#1-(float(trans_var.get())-math.floor(float(trans_var.get())))
			try:
				gp_commands.append('set title "' + title_var.get() + '"') #
			except:
				print("errorTITLEentry")
		else:
			try:
				gp_commands.append('unset title') #
			except:
				print("errorTITLEentry")
		gp_commands.append(get_gnuplot_command(config2[0]["key_placement"]))			
		# ~ gp_commands.append('set border linecolor rgb "' + border_color_button.cget("bg") + '"')
		
		#hier
		# ~ gp_commands.append('set border linecolor rgb "' + config2[0]["bordercolor"] + '"')

		if(config2[0]["borderwidth"] == ""):
			# ~ print(round(1-float(trans_var.get()),2))
			# ~ print(str(round(1-float(trans_var.get())-math.floor(float(trans_var.get())),2)))#1-(float(trans_var.get())-math.floor(float(trans_var.get())))
			try:
				gp_commands.append('unset border') #
				print('unset UNSER UNSET UNSET border') #
				# ~ gp_commands.append('set title "' + title_var.get() + '"') #
			except:
				print("ERrORborderENTRY but very strange")
		else:
			# ~ gp_commands.append('set border')
			gp_commands.append('set border')
			gp_commands.append('set border linewidth "' + config2[0]["borderwidth"] + '" linecolor rgb "' + config2[0]["bordercolor"] + '"')


		if(config2[0]["xtics"]):
			gp_commands.append("set xtics")
		else:
			gp_commands.append("unset xtics")
		if(config2[0]["ytics"]):
			gp_commands.append("set ytics")
		else:
			gp_commands.append("unset ytics")
		if(config2[0]["logx"]):
			gp_commands.append("set logscale x")
		else:
			gp_commands.append("unset logscale x")
		#gp_commands.append('set xlabel "' + widgets_extra[0]["xlabel"].get() + '" textcolor rgb "' + x_color_button.cget("bg") + '"')
		gp_commands.append("set xrange [" + widgets_extra[0]["xrange1"].get() + ":" + widgets_extra[0]["xrange2"].get() + ']')
		gp_commands.append("set yrange [" + widgets_extra[0]["yrange1"].get() + ":" + widgets_extra[0]["yrange2"].get() + ']')
		#gp_commands.append('set ylabel "' + widgets_extra[0]["ylabel"].get() + '" textcolor rgb "' + y_color_button.cget("bg") + '"')
		
		if (widgets_extra[0]["gridcheck"].get() == True):
			gp_commands.append("set grid")
		else:
			gp_commands.append("unset grid")
			
		if (widgets_extra[0]["logcheck"].get() == True):
			gp_commands.append("set logscale y")
		else:
			gp_commands.append("unset logscale y")
		

		if(config2[0]["showx1"] == False):
			gp_commands.append("unset xlabel")
		else:
			gp_commands.append('set xlabel "' + widgets_extra[0]["xlabel"].get() + '" textcolor rgb "' + config2[0]["x1color"] + '"')
			
		if(config2[0]["showy1"] == False):
			gp_commands.append("unset ylabel")
		else:
			gp_commands.append('set ylabel "' + widgets_extra[0]["ylabel"].get() + '" textcolor rgb "' + config2[0]["y1color"] + '"')
			
		if(config2[0]["showy2"] == False):
			gp_commands.append("unset y2label")
		else:
			gp_commands.append('set y2label "' + config2[0]["y2label"] + '" textcolor rgb "' + config2[0]["y2color"] + '"')
			
		if(config2[0]["showx2"] == False):
			gp_commands.append("unset x2label")
		else:
			gp_commands.append('set x2label "' + config2[0]["x2label"] + '" textcolor rgb "' + config2[0]["x2color"] + '"')

		gp_commands.append(config2[0]["customcommands"])



		
		# ~ for i, widget_set in enumerate(widgets):
			# ~ print(f"Widget {i}:")
			# ~ mylist.append(widget_set['file_path_var'].get())
			# ~ print(f"  Button Color: {widget_set['button_color_var'].get()}")
			# ~ print(f"  Dropdown Value: {widget_set['dropdown_var'].get()}")
			# ~ print(f"  Small Text: {widget_set['small_text_var'].get()}")			

		# ~ mylist.append(widgets_extra[0]["xlabel"].get())
		# ~ mylist.append(widgets_extra[0]["xrange1"].get())
		# ~ mylist.append(widgets_extra[0]["xrange2"].get())
		# ~ mylist.append(widgets_extra[0]["ylabel"].get())
		# ~ mylist.append(widgets_extra[0]["yrange1"].get())
		# ~ mylist.append(widgets_extra[0]["yrange2"].get())
		# ~ mylist.append(widgets_extra[0]["gridcheck"].get())
		# ~ mylist.append(widgets_extra[0]["logcheck"].get())
		# ~ mylist.append(widgets_extra[0]["plotstyle"].get())
		# ~ mylist.append(widgets_extra[0]["plotway"].get())
		# ~ mylist.append(widgets_extra[0]["outputname"].get())
		# ~ mylist.append(widgets_extra[0]["outputradio"].get())

		
		if ('Multiple' in widgets_extra[0]["plotway"].get()):
			if(widgets_extra[0]["outputradio"].get()=="png"):
				gp_commands.append("set terminal pngcairo size 800,600 enhanced")
			elif(widgets_extra[0]["outputradio"].get()=="pdf"):
				gp_commands.append("set terminal pdf")
			# ~ elif(widgets_extra[0]["outputradio"].get()=="interactive window"):
				# ~ for i,filenm in enumerate(flnmlst):					
					# ~ gp_commands.append("set terminal wxt " + str(i))

		plo.save(dataonly, tmp_file)
		# ~ plo.save(add_to_list_elements(dataonly,config2[0]["offset_var"]), tmp_file)
		for cmd in gp_commands:
			plo.c(cmd)	
			print(cmd)
			# ~ print("HEEEEEEEEEEEEEEEEEEEEEEEEEEE")
			
#str(float(spedatalist[i][7][1].split()[0])) + '+' + str(float(spedatalist[i][7][1].split()[1])) + '*column(0)+' + str(float(spedatalist[i][7][1].split()[2])) + '*column(0)**2)'
	
		if (widgets_extra[0]["plotway"].get() == 'Single plot channels'):
			make_plotlines(True) #channels instead of energy is True
			pstring = 'plot '
			for i,element in enumerate(plotlines):
				pstring += plotlines[i]
				if i+1<len(plotlines):
					pstring += ', '
		if (widgets_extra[0]["plotway"].get() == 'Multiple plots channels'):
			# ~ pstring = 'plot '
			make_plotlines(True)	#channels instead of energy is True	
		
		
				
		if (widgets_extra[0]["plotway"].get() == 'Single plot energy'):
			pstring = 'plot '
			make_plotlines(False) #energy instead of channels is False
			for i,element in enumerate(plotlines):
				pstring += plotlines[i]
				if i+1<len(plotlines):
					pstring += ', '
		if (widgets_extra[0]["plotway"].get() == 'Multiple plots energy'):
			make_plotlines(False) #energy instead of channels is False		
		




		multiterm_com = []
		plostring='plot '			
		if ('Multiple' in widgets_extra[0]["plotway"].get()):
			if(widgets_extra[0]["outputradio"].get()=="interactive window"):
				if exportGPfile:
					plot_strings = generate_plots_with_counts(plotlines, gpc_indices)
					for d,stri in enumerate(plot_strings):
						multiterm_com.append('set terminal wxt ' + str(d+1))
						multiterm_com.append(stri)
					for mri in multiterm_com:
						gp_commands.append(mri)					
				else:	
					plot_strings = generate_plots_with_counts(plotlines, gpc_indices)
					for d,stri in enumerate(plot_strings):
						multiterm_com.append('set terminal wxt ' + str(d+1))
						multiterm_com.append(stri)
					for mri in multiterm_com:
						plo.c(mri)

			if(widgets_extra[0]["outputradio"].get()=="png"):
				if exportGPfile:
					plot_strings = generate_plots_with_counts(plotlines, gpc_indices)
					for d,stri in enumerate(plot_strings):
						gp_commands.append('set output "' + ensure_unique_filename(str(spedatalist[d][1]) + '.png') + '"' )
						gp_commands.append(stri)
						gp_commands.append('unset output')
				else:
					plot_strings = generate_plots_with_counts(plotlines, gpc_indices)
					for d,stri in enumerate(plot_strings):
						plo.c('set output "' + ensure_unique_filename(str(spedatalist[d][1]) + '.png') + '"' )
						plo.c(stri)
						sleep(.2)
					plo.c('unset output')
			if(widgets_extra[0]["outputradio"].get()=="pdf"):
				if exportGPfile:
					plot_strings = generate_plots_with_counts(plotlines, gpc_indices)
					for d,stri in enumerate(plot_strings):
						gp_commands.append('set output "' + ensure_unique_filename(str(spedatalist[d][1]) + '.pdf') + '"' )
						gp_commands.append(stri)
						gp_commands.append('unset output')
				else:
					plot_strings = generate_plots_with_counts(plotlines, gpc_indices)
					for d,stri in enumerate(plot_strings):
						plo.c('set output "' + ensure_unique_filename(str(spedatalist[d][1]) + '.pdf') + '"' )
						plo.c(stri)
						sleep(.2)
					plo.c('unset output')
		else:
			if exportGPfile:
				gp_commands.append(pstring)
				if(widgets_extra[0]["outputradio"].get()=="pdf" or widgets_extra[0]["outputradio"].get()=="png"):
					gp_commands.append('unset output')
			else:	
				plo.c(pstring)
				if(widgets_extra[0]["outputradio"].get()=="pdf" or widgets_extra[0]["outputradio"].get()=="png"):
					plo.c('unset output')
				print(pstring)		
		# ~ print(pstring)		
		# ~ print(efficy)
		if exportGPfile:
			return gp_commands
			print(gp_commands)
			
			
		

		# ~ print('set style fill transparent solid ' + str(1-round(float(trans_var.get())-math.floor(float(trans_var.get())),2)) + ' noborder') #TRANSPARENCYYYYY
		# ~ if (widgets_extra[0]["logcheck"].get() == True):
			# ~ print("logcheck true!")
		# ~ else:
			# ~ print(widgets_extra[0]["logcheck"].get())


		# ~ plotline = 'plot "' + tmp_file + '" using (column(0)):1 with lines dashtype 1'
		# ~ plotlines.append(plotline)
		


		# ~ for pline in plotlines:
			# ~ plo.c(pline)
		# ~ print(widgets[1])
		# ~ print(spedatalist)
		# ~ plo.c("plot " + plotlines[0])
		# ~ print("plot " + plotlines[0])
		# ~ plo.c(plotlines[0])
		# ~ print(plotlines[0])
		# ~ print(plotlines)
		# ~ print(get_filenames())
			
	def open_settings_window(config):

		def update_label(event):
			dropdown_label2.config(text=dropdown_key_var.get()) #in theory it should work without this, but during development it was needed for the value to show up overall
		
		def is_float(entry_widget):
			value = entry_widget.get()
			try:
				float(value)
				entry_widget.config(fg="black")
			except ValueError:
				entry_widget.config(fg="red")
				if value == "":
					entry_widget.config(fg="black")
		def validate_input(entry_widget):
			"""
			Validates the content of an Entry widget.
			Changes the text color to red if invalid, otherwise black.
			"""
			try:
				# Versuche, den Inhalt als Zahl zu interpretieren
				value = float(entry_widget.get())
				if 0 <= value <= 1:
					entry_widget.config(fg="black")  # Gültige Eingabe
				else:
					entry_widget.config(fg="red")  # Zahl außerhalb des Bereichs
			except ValueError:
				entry_widget.config(fg="red")  # Ungültige Eingabe
			
		def validate_numeric(entry_widget):
			"""
			Validates the content of an Entry widget to ensure it contains only numeric input.
			Changes the text color to red if invalid, otherwise black.
			"""
			content = entry_widget.get()
			if content.isnumeric() or content == "":  # Allow only numeric input or empty input
				entry_widget.config(fg="black")
			else:
				entry_widget.config(fg="red")
		def validate_windows(entry_widget):
			"""
			Validates the content of an Entry widget to ensure it contains only numeric input.
			Changes the text color to red if invalid, otherwise black.
			"""
			
			content = entry_widget.get()

				
			if content.isnumeric() or content == "":  # Allow only numeric input or empty input
				# ~ entry_widget.config(fg="black")
				if str(content) == str(config["file_count"]):  # text="(at next restart)"
					entry_widget.config(fg="black")
					windows_entry_label2.config(text="(at next restart)")						
				else:
					entry_widget.config(fg="green")
					windows_entry_label2.config(text="!- restart recommended -!")
				if (int(content) - 15 >= 0):
					windows_entry_label2.config(text="at fail: delete .json file")									
			else:
				entry_widget.config(fg="red")
				windows_entry_label2.config(text="((strange input))")
				
		def on_closing():
			print(config.get("roicolor"))
			config["title_var"] = number1_var.get()
			config["comment_var"] = comment_var.get()
			config["customcommands"] = custom_text.get("1.0", "end").strip() 
			config["bordercolor"] = bordercolor_button.cget("bg")
			config["offset_var"] = offset_var.get()
			config["xoffset_var"] = xoffset_var.get()
			config["key_placement"] = dropdown_key.get()
			config["file_count"] = windows_entry_var.get()
			config["logx"] = logx_var.get()
			config["xtics"] = xtics_var.get()
			config["ytics"] = ytics_var.get()
			config["borderwidth"] = borderwidth_var.get()
			config["transparency"] = gtrans_var.get()
			config["x2label"] = x2label_var.get()
			config["y2label"] = y2label_var.get()
			config["showx1"] = x1label_bool.get()
			config["showx2"] = x2label_bool.get()
			config["showy1"] = y1label_bool.get()
			config["showy2"] = y2label_bool.get()
			config["x1color"] = x1label_color_button.cget("bg")
			config["x2color"] = x2label_color_button.cget("bg")
			config["y1color"] = y2label_color_button.cget("bg")
			config["y2color"] = y1label_color_button.cget("bg")
			
			print("Saved Advanced Settings in Main-Dictionary")
			settings_window.destroy()
		def just_save():
			print(config.get("roicolor"))
			config["title_var"] = number1_var.get()
			config["customcommands"] = custom_text.get("1.0", "end").strip() 
			config["comment_var"] = comment_var.get()
			config["bordercolor"] = bordercolor_button.cget("bg")
			config["offset_var"] = offset_var.get()
			config["xoffset_var"] = xoffset_var.get()
			config["key_placement"] = dropdown_key.get()
			config["file_count"] = windows_entry_var.get()
			config["logx"] = logx_var.get()
			config["xtics"] = xtics_var.get()
			config["ytics"] = ytics_var.get()
			config["borderwidth"] = borderwidth_var.get()
			config["transparency"] = gtrans_var.get()
			config["x2label"] = x2label_var.get()
			config["y2label"] = y2label_var.get()
			config["showx1"] = x1label_bool.get()
			config["showx2"] = x2label_bool.get()
			config["showy1"] = y1label_bool.get()
			config["showy2"] = y2label_bool.get()
			config["x1color"] = x1label_color_button.cget("bg")
			config["x2color"] = x2label_color_button.cget("bg")
			config["y1color"] = y2label_color_button.cget("bg")
			config["y2color"] = y1label_color_button.cget("bg")
			
			print("Saved Advanced Settings in Main-Dictionary")
			# ~ settings_window.destroy()
			
		def validate_number(entry, text_var):
			try:
				float(entry.get())
				text_var.set("")  # Entfernt die rote Farbe
			except ValueError:
				# ~ text_var.set(
				text_var.set("Bitte eine Zahl eingeben!")  # Zeigt eine Fehlermeldung

		def pick_color(button):
			color_code = colorchooser.askcolor(title="Farbe auswählen")[1]
			if color_code:
				button.config(bg=color_code)

		settings_window = tk.Toplevel(root)
		settings_window.title("Advanced Settings")
		settings_window.geometry("850x550")

		# Textfelder für Zahlen
		number1_var = tk.StringVar(value=config["title_var"])
		# ~ number1_entry = tk.Entry(settings_window, textvariable=number1_var)
		number1_entry = tk.Entry(settings_window, textvariable=title_var)
		number1_label = tk.Label(settings_window, text="Graph title:")
		number1_label2 = tk.Label(settings_window, text="(above plot)")
		number1_message = tk.Label(settings_window, text="", fg="red")
		# ~ number1_var.trace("w", lambda *args: validate_number(number1_entry, number1_message))

		offset_var = tk.StringVar(value=config["offset_var"])
		xoffset_var = tk.StringVar(value=config["xoffset_var"])
		offset_entry = tk.Entry(settings_window, textvariable=offset_var)
		xoffset_entry = tk.Entry(settings_window, textvariable=xoffset_var)
		offset_label = tk.Label(settings_window, text="Y offset per spectrum:")
		offset_label2 = tk.Label(settings_window, text="X offset per spectrum:")
		offset_message = tk.Label(settings_window, text="", fg="red")
		# ~ offset_var.trace("w", lambda *args: validate_number(number2_entry, number2_message))

		# Drop-Down-Menü
		dropdown_key_var = tk.StringVar(value=config["key_placement"]) #1
		# ~ dropdown_key_var = tk.StringVar(value="top left in") #2
		# ~ new_key_var = tk.StringVar(value="top left in")
		# ~ dropdown = tk.OptionMenu(settings_window, dropdown_var, *[f"Option {i}" for i in range(1, 17)])
		dropdown_key = ttk.Combobox(settings_window, textvariable=dropdown_key_var, values=["top left in", "top right in", "top center in", "top center in horiz", "bottom left in", "bottom right in","left in", "right in","center in","top left out","top center out","top center out horiz","bottom left out","bottom right out","bottom center out","outside left","outside right"], state="readonly")
		# ~ dropdown_key = ttk.Combobox(settings_window, textvariable=new_key_var, values=["top left in", "top right in", "top center in"], state="readonly")
		dropdown_label = tk.Label(settings_window, text="Key placement:")
		dropdown_label2 = tk.Label(settings_window, text=dropdown_key_var.get())
		
		# ~ dropdown_key.set("top left out")	
		# ~ settings_window.update_idletasks()
		# ~ print("Initial value in dropdown_key_var:", dropdown_key_var.get())
		# ~ print("Current value in Combobox:", dropdown_key.get())	
		# ~ print("weiters")
		# ~ print(config["key_placement"]) #3		
		# ~ print(dropdown_key_var.get())

		# ~ print("Dropdown values:", dropdown_key["values"])
		# ~ print("Dropdown current value:", dropdown_key.get())
		# ~ print("StringVar value:", dropdown_key_var.get())

		# Textfeld mit Checkbox und Farbauswahlbutton (x1label)
		x1label_bool = tk.BooleanVar(value=config["showx1"])
		x1label_checkbox = tk.Checkbutton(settings_window, text="Show x1label", variable=x1label_bool)
		x1label_color_button = tk.Button(settings_window, text="x1color", bg=config["x1color"], fg="#ffffff", command=lambda: pick_color(x1label_color_button))
		x2label_bool = tk.BooleanVar(value=config["showx2"])
		x2label_checkbox = tk.Checkbutton(settings_window, text="Show x2label", variable=x2label_bool)
		x2label_color_button = tk.Button(settings_window, text="x2color", bg=config["x2color"], fg="#ffffff", command=lambda: pick_color(x2label_color_button))

		x2label_label = tk.Label(settings_window, text="x2 label:")
		x2label_var = tk.StringVar(value=config["x2label"])
		x2label_entry = tk.Entry(settings_window, textvariable=x2label_var)
		y2label_label = tk.Label(settings_window, text="y2 label:")
		y2label_var = tk.StringVar(value=config["y2label"])
		y2label_entry = tk.Entry(settings_window, textvariable=y2label_var)
		#graph transparency
		gtrans_label = tk.Label(settings_window, text="Graph transparency:")
		gtrans_label2 = tk.Label(settings_window, text="(0 - 0.99)")
		gtrans_var = tk.StringVar(value=config["transparency"])
		gtrans_entry = tk.Entry(settings_window, textvariable=gtrans_var)

		# Textfeld mit Checkbox und Farbauswahlbutton (y2label)
		y1label_bool = tk.BooleanVar(value=config["showy1"])
		y1label_checkbox = tk.Checkbutton(settings_window, text="Show y1label", variable=y1label_bool)
		y1label_color_button = tk.Button(settings_window, text="y1color", bg=config["y1color"], fg="#ffffff", command=lambda: pick_color(y1label_color_button))
		y2label_bool = tk.BooleanVar(value=config["showy2"])
		y2label_checkbox = tk.Checkbutton(settings_window, text="Show y2label", variable=y2label_bool)
		y2label_color_button = tk.Button(settings_window, text="y2color", bg=config["y2color"], fg="#ffffff", command=lambda: pick_color(y2label_color_button))

		# Weitere Farbauswahlbuttons
		bordercolor_button = tk.Button(settings_window, text="Border color",  bg=config["bordercolor"], fg="#ffffff", command=lambda: pick_color(bordercolor_button))
		borderwidth_var = tk.StringVar(value=config["borderwidth"])
		borderwidth_entry = tk.Entry(settings_window, textvariable=borderwidth_var)
		borderwidth_label = tk.Label(settings_window, text="Border width:")
		borderwidth_label2 = tk.Label(settings_window, text="<- empty for toggle off")
		# ~ y1color_button = tk.Button(settings_window, text="y1color", command=lambda: pick_color(y1color_button))

		# Weitere Checkboxen
		xtics_var = tk.BooleanVar(value=config["xtics"])
		xtics_checkbox = tk.Checkbutton(settings_window, text="xtics", variable=xtics_var)

		ytics_var = tk.BooleanVar(value=config["ytics"])
		ytics_checkbox = tk.Checkbutton(settings_window, text="ytics", variable=ytics_var)
		
		logx_var = tk.BooleanVar(value=config["logx"])
		logx_checkbox = tk.Checkbutton(settings_window, text="logscale x", variable=logx_var)

		# ~ additional_checkbox_vars = [tk.BooleanVar() for _ in range(3)]
		# ~ additional_checkboxes = [
			# ~ tk.Checkbutton(settings_window, text=f"Option {i + 1}", variable=var)
			# ~ for i, var in enumerate(additional_checkbox_vars)
		# ~ ]

		# Weitere Textfelder
		comment_var = tk.StringVar(value=config["comment_var"])
		comment_field1 = tk.Entry(settings_window, textvariable=comment_var, width=35)
		comment_field1_label = tk.Label(settings_window, text="Comment from .json file")
		windows_entry_label = tk.Label(settings_window, text="How many files per Window:")
		windows_entry_label2 = tk.Label(settings_window, text="(at next restart)")
		windows_entry_var = tk.StringVar(value=config["file_count"])
		windows_entry = tk.Entry(settings_window, textvariable=windows_entry_var, width=10)
		
		# ~ customcommands = tk.StringVar(value=config["customcommands"])
		custom_descr = tk.Label(settings_window, text="Custom commands:")
		custom_text = tk.Text(
			settings_window, wrap="word", height=3, width=50, bg="gray", fg="#02ff20", font=("Arial", 12, "bold")
		)
		custom_text.insert("1.0",config["customcommands"])
		# Schließen-Buttons
		close_button = tk.Button(settings_window, text="Okay, close", height=2, command=on_closing, fg="#0D5A0C")
		save_button = tk.Button(settings_window, text="Apply",font=("TkDefaultFont",16), height=2, width=12, command=just_save, fg="#09D209")
		abort_button = tk.Button(settings_window, text="Cancel", command=settings_window.destroy, fg="#CF010B")

		
		windows_entry.bind("<KeyRelease>", lambda event: validate_windows(windows_entry))
		offset_entry.bind("<KeyRelease>", lambda event: validate_numeric(offset_entry))
		xoffset_entry.bind("<KeyRelease>", lambda event: validate_numeric(xoffset_entry))
		gtrans_entry.bind("<KeyRelease>", lambda event: validate_input(gtrans_entry))
		borderwidth_entry.bind("<KeyRelease>", lambda event: is_float(borderwidth_entry))
		dropdown_key.bind("<<ComboboxSelected>>", update_label)
		
		# Grid-Anordnung
		number1_label.grid(row=0, column=0, sticky="w")
		number1_label2.grid(row=0, column=2, padx=5, sticky="w")
		number1_entry.grid(row=0, column=1, sticky="w")
		number1_message.grid(row=0, column=2, sticky="w")

		offset_label.grid(row=1, column=0, sticky="w")
		offset_label2.grid(row=1, column=2, padx=5, sticky="w")
		offset_entry.grid(row=1, column=1, sticky="w")
		xoffset_entry.grid(row=1, column=3, sticky="w")
		offset_message.grid(row=1, column=2, sticky="w")

		dropdown_label.grid(row=2, column=0, sticky="w")
		dropdown_label2.grid(row=2, column=2, sticky="w")
		dropdown_key.grid(row=2, column=1, sticky="w")

		x1label_checkbox.grid(row=3, column=0, sticky="w")
		x1label_color_button.grid(row=3, column=1, sticky="w")
		x2label_checkbox.grid(row=3, column=4, sticky="w")
		x2label_color_button.grid(row=3, column=3, sticky="w")

		y1label_checkbox.grid(row=4, column=0, sticky="w")
		y1label_color_button.grid(row=4, column=1, sticky="w")
		y2label_checkbox.grid(row=4, column=4, sticky="w")
		y2label_color_button.grid(row=4, column=3, sticky="w")

		x2label_label.grid(row=3, column=1, sticky="e")
		y2label_label.grid(row=4, column=1, sticky="e")
		x2label_entry.grid(row=3, column=2, sticky="w")
		y2label_entry.grid(row=4, column=2, sticky="w")
		
		gtrans_label.grid(row=5, column=0, sticky="w")
		gtrans_label2.grid(row=5, column=2, sticky="w")
		gtrans_entry.grid(row=5, column=1, sticky="e")

		bordercolor_button.grid(row=6, column=0, sticky="w")
		# ~ y1color_button.grid(row=5, column=1, sticky="w")
		borderwidth_label.grid(row=6, column=1, sticky="e")
		borderwidth_label2.grid(row=6, column=2, sticky="e")
		borderwidth_entry.grid(row=6, column=2, sticky="w")

		xtics_checkbox.grid(row=7, column=0, sticky="w")
		ytics_checkbox.grid(row=7, column=1, sticky="w")
		logx_checkbox.grid(row=7, column=2, sticky="w")

		# ~ for i, checkbox in enumerate(additional_checkboxes, start=7):
			# ~ checkbox.grid(row=i, column=0, sticky="w")

		comment_field1.grid(row=11, column=2, columnspan=2, sticky="w")
		comment_field1_label.grid(row=11, column=1, columnspan=1, sticky="e")
		windows_entry.grid(row=12, column=1, columnspan=1, sticky="we")
		windows_entry_label.grid(row=12, column=0, columnspan=1, sticky="we")
		windows_entry_label2.grid(row=13, column=1, columnspan=1, sticky="we")

		custom_text.grid(row=14, column=1, columnspan=4,sticky="w")
		custom_descr.grid(row=14, column=0,sticky="w")

		close_button.grid(row=15, column=2, columnspan=3, pady=50) 
		abort_button.grid(row=15, column=0, columnspan=3, pady=50) 
		save_button.grid(row=15, column=1, columnspan=3, pady=50) 
		
	def open_help_window():
			# ~ print(color_code)
		# ~ global roi_color_var
		# ~ print(roi_color_var)
		# Neues Toplevel-Fenster erstellen
		help_window = tk.Toplevel(root)
		help_window.title("Help")
		help_window.geometry("700x700")  # Größeres Fenster

				
		gnu_plot_script = [
			"set xyplane at -1.5",
			"set view 70, 125",
			"set grid lw 2",
			"unset key",
			"",
			"i=10",
			"iy_min=-10",
			"y_min=-10",
			"y_max=20",
			"while (i<200){",
			"splot [-2:2][y_min:y_max][-1.5:1.5] sample \\",
			"                               [a=iy_min:i:0.2] '+' using (cos(a)):(a):(sin(a)) lt 5 lc rgb 'purple' lw 3,\\",
			"                               [a=iy_min:i:0.1] '' using (cos(a)):(y_min):(sin(a)) w l lw 2, \\",
			"                               [a=iy_min:i:0.1] '' using (-2):(a):(sin(a)) w l lw 2, \\",
			"                               [a=iy_min:i:0.1] '' using (cos(a)):(a):(-1.5) w l lw 2, \\",
			"                               [c=iy_min:i] '' using (cos(i)):(c):(sin(i)) w l lc rgb 'dark-green',\\",
			"                               [e=-2:cos(i)] '' using (e):(i):(sin(i)) w l lc rgb 'dark-blue',\\",
			"                               [f=-1.5:sin(i)] '' using (cos(i)):(i):(f) w l lc rgb 'dark-orange'",
			"#                               [e=-2:1] '' using (e):(0):(0) w l lc rgb 'dark-red',\\",
			"#                               [f=-10:0] '' using (1):(f):(0) w l lc rgb 'dark-red'",
			"i=i+0.098",
			"y_min=y_min+0.1",
			"y_max=y_max+0.1",
			"pause 0.01",
			"}",
			"",
			"pause -1"
		]

		
		# Hilfetexte in verschiedenen Sprachen
		help_texts = {
			"de": (
				"Dieses Programm dient vornehmlich dem Plotten von Spektren (.Spe-Dateien), die mit Maestro-Software wie GammaVision aufgenommen wurden.\n"
				"Bis zu zehn oder mehr (einstellbar, max 100) Spektren können gleichzeitig eingelesen und geplottet werden. Spektren können als Argumente beim Programmstart übergeben werden, wodurch die Felder für den Dateipfad automatisch ausgefüllt werden. "
				"Falls mehr Argumente als eingestellt übergeben werden, werden entsprechend weitere Instanzen des Programms gestartet, wobei jede Instanz maximal die eingestellte Anzahl an Dateien bearbeitet. Abgesehen davon ist die Anzahl der Argumente unbegrenzt.\n"
				"Bei plötzlichen Problemen kann es helfen die .json Konfigurationsdatei zu löschen -> Standardkonfiguration wird geladen!\n"
				"Das Programm bietet folgende Funktionen:\n"
				"- Speicherung der eingestellten Optionen für den nächsten Programmstart\n"
				"- Plotten als .pdf, .png oder im interaktiven Fenster\n"
				"- Plotten gegen Kanäle oder Energie\n"
				"- Plotten mit Offset (x,y) bei mehreren: pro Spektrum\n"
				"- Einzelplots pro Spektrum oder mehrere Spektren pro Graph\n"
				"- Exportieren der Plotanweisungen für gnuplot als .gp-Datei\n"
				"- Diverse Plotoptionen (z. B. Plotten gegen Kanäle oder Energie, Einzelplots pro Datei oder bis zu zehn oder mehr (einstellbar) Spektren pro Graph, Korrektur der Counts durch Division zur Effizienzkorrektur oder Zählratenberechnung, Hervorheben von ROIs in anderer Farbe usw.)\n"
				"- Anzeige und Speicherung von Metadaten der Spektrendateien\n"
				"- Anzeige und Speicherung aller ROIs (inklusive Bruttocounts) der Spektrendateien\n"
				"- Konvertierung der Spektren in Tabellenform (.csv oder .xlsx: Kanäle, Energie, Counts, korrigierte Counts)\n"
				"- Konvertierung der Spektren fuer HDTV (1-column ASCIi; Effizienzdatei anbei)\n"
				"- Addition der Spektren (nützlich für unterbrochene Langzeitmessungen; Addition Kanal für Kanal; die Messzeit wird ebenfalls addiert, Metadaten des ersten Spektrums, außer summierte Messzeit bleiben erhalten)\n"
				"- Subtraktion der (anderen) Spektren vom ersten/obersten Spektrum (nützlich für Untergrundsubtraktionen; skaliert auf die kleinste Messzeit, falls nötig, Metadaten des ersten Spektrums bleiben erhalten; negative Counts optional deaktivierbar)\n"
				"- Alle Funktionen sind über das Drop-Down-Menü auch ohne GUI automatisiert verfügbar (z. B. per Drag & Drop; besonders nützlich für Stapelverarbeitung ohne manuelle Intervention)\n"
				"Das Programm versucht, keine existierenden Dateien zu überschreiben, und hängt stattdessen ein \"x\" an vorhandene Dateinamen an.\n"
				"\n"
				"Automation/Stapelverarbeitung kann im Drop-Down-Menü links unten eingestellt werden. \n"
				"Befindet sich das Programm im automatischen Modus und wird mit Argumenten (Dateien per Drag&Drop auf dieses Programm, Pfade zu Spektrendateien) gestartet, wird die jeweilige Aktion automatisch ausgeführt, und das Programm beendet sich danach automatisch (außer bei interaktiven Plots).\n"
				"Um den automatischen Modus zu deaktivieren, muss das Programm ohne Argumente gestartet werden.\n"
				"Hinweis: Gnuplot sollte installiert sein (am besten im PATH registriert, getestet mit Version 5.4).\n"
				"Hinweis: Gnuplot ist fuer Windows bereits enthalten (muss nicht installiert sein).\n"
				"Version 3.1.1"
			),
			"en": (
				"This program is primarily used to plot spectra (.Spe files) recorded using Maestro software such as GammaVision.\n"
				"Up to ten ore more (advanced settings, max 100) spectra can be imported and plotted simultaneously. Spectra can be provided as arguments when launching the program, which automatically fills the file path fields. "
				"If more than ten arguments are given, additional instances of the program are started, with each instance processing up to the set amount of files. The number of arguments is unlimited.\n"
				"By encountering sudden problems try to delete the .json file!\n"
				"The program offers the following features:\n"
				"- Saving the configured options for the next program launch\n"
				"- Plotting as .pdf, .png, or in an interactive window\n"
				"- Plotting against channels or energy\n"
				"- Plotting with x/y offset per spectrum for comparison\n"
				"- Individual plots per spectrum or multiple spectra on one graph\n"
				"- Exporting plot commands for Gnuplot as .gp\n"
				"- Various plotting options (e.g., plotting against channels or energy, single plots per file or up to ten or more spectra on one graph, correcting counts by division for efficiency correction or count rate calculation, ROIs in different colors, etc.)\n"
				"- Displaying and saving metadata of the spectrum files\n"
				"- Displaying and saving all ROIs (including gross counts) of the spectrum files\n"
				"- Converting spectra into table form .csv (channels, energy, counts, corrected counts)\n"
				"- Adding spectra (useful for interrupted long-term measurements; measurement time is summed up, metadata of the first spectrum are retained)\n"
				"- Subtracting spectra (useful for background subtraction; scaled to the shortest measurement time if necessary; metadata of the first spectrum are retained, option to disable negative counts)\n"
				"- All functions are available in the drop-down menu even without GUI (drag & drop; especially useful for batch processing without interventions)\n"
				"Gnuplot must be installed (preferably registered in the PATH; tested with version 5.4).\n"
				"The program avoids overwriting existing files and instead appends an 'x' to existing file names.\n"
				"\n"
				"Automation and batch processing can be configured in the drop-down menu in the lower left corner. "
				"To disable automatic mode, start the program without arguments.\n"
				"If the program is in automatic mode and started with arguments (paths to spectrum files), the respective action will be performed automatically, and the program will then terminate (except for interactive plots).\n"
			),
			"pl": (
				"Ten program służy głównie do tworzenia wykresów spektrogramów (.Spe) zapisanych za pomocą oprogramowania Maestro, takiego jak GammaVision.\n"
				"Można jednocześnie wczytać i zwizualizować do dziesięciu spektrogramów. Spektrogramy mogą być przekazywane jako argumenty podczas uruchamiania programu, co automatycznie wypełni pola ścieżki pliku. "
				"Jeśli zostanie przekazanych więcej niż dziesięć argumentów, uruchamiane są kolejne instancje programu, z których każda obsługuje maksymalnie dziesięć plików. Liczba argumentów jest nieograniczona.\n"
				"Program oferuje następujące funkcje:\n"
				"- Zapisywanie ustawień opcji dla następnego uruchomienia programu\n"
				"- Tworzenie wykresów w formacie .pdf, .png lub w interaktywnym oknie\n"
				"- Wykresy w odniesieniu do kanałów lub energii\n"
				"- Wykresy pojedyncze dla każdego spektrogramu lub wiele spektrogramów na jednym wykresie\n"
				"- Eksportowanie poleceń wykresu do Gnuplot jako .gp\n"
				"- Różnorodne opcje wykresów (np. wykresy według kanałów lub energii, pojedyncze wykresy na plik lub maksymalnie dziesięć spektrogramów na wykresie, korekcja liczby impulsów przez podział dla korekcji wydajności lub obliczeń współczynnika zliczeń, ROIs w innym kolorze itd.)\n"
				"- Wyświetlanie i zapisywanie metadanych plików spektrogramów\n"
				"- Wyświetlanie i zapisywanie wszystkich ROIs (w tym liczby brutto) z plików spektrogramów\n"
				"- Konwersja spektrogramów do formatu tabeli .csv (kanały, energia, liczba impulsów, skorygowana liczba impulsów)\n"
				"- Dodawanie spektrogramów (przydatne dla przerwanych długoterminowych pomiarów; czas pomiaru jest sumowany, metadane pierwszego spektrogramu zostają zachowane)\n"
				"- Odejmowanie spektrogramów (przydatne dla odejmowania tła; skalowanie do najkrótszego czasu pomiaru w razie potrzeby; metadane pierwszego spektrogramu zostają zachowane, możliwość wyłączenia ujemnych liczników)\n"
				"- Wszystkie funkcje są dostępne w menu rozwijanym także bez GUI (Drag & Drop; szczególnie przydatne do przetwarzania wsadowego bez interwencji użytkownika)\n"
				"Gnuplot musi być zainstalowany (najlepiej zarejestrowany w PATH; testowano na wersji 5.4).\n"
				"Program unika nadpisywania istniejących plików, zamiast tego dodaje 'x' do nazw plików.\n"
				"\n"
				"Automatyzację i przetwarzanie wsadowe można ustawić w menu rozwijanym w lewym dolnym rogu. "
				"Aby wyłączyć tryb automatyczny, należy uruchomić program bez argumentów.\n"
				"Jeśli program jest w trybie automatycznym i zostanie uruchomiony z argumentami (ścieżkami do plików spektrogramów), odpowiednia akcja zostanie automatycznie uruchomiona, a program zakończy działanie (z wyjątkiem wykresów interaktywnych).\n"
			),
			"cz": (
				"Tento program slouží především k vykreslování spekter (.Spe soubory) zaznamenaných pomocí softwaru Maestro, například GammaVision.\n"
				"Je možné současně načíst a vykreslit až deset spekter. Spektra mohou být předána jako argumenty při spuštění programu, což automaticky vyplní pole pro cesty k souborům. "
				"Pokud je zadáno více než deset argumentů, spustí se odpovídající další instance programu, přičemž každá instance zpracuje maximálně deset souborů. Počet argumentů není omezen.\n"
				"Program nabízí následující funkce:\n"
				"- Uložení nastavení pro příští spuštění programu\n"
				"- Vykreslování do formátu .pdf, .png nebo do interaktivního okna\n"
				"- Vykreslování vůči kanálům nebo energiím\n"
				"- Jednotlivé grafy pro každé spektrum nebo více spekter na jednom grafu\n"
				"- Export příkazů grafu pro Gnuplot jako .gp\n"
				"- Různé možnosti vykreslování (např. grafy podle kanálů nebo energie, jednotlivé grafy na soubor nebo až deset spekter na grafu, korekce počtu impulzů vydělením pro účely korekce účinnosti nebo výpočtu rychlosti počítání, ROIs v jiných barvách atd.)\n"
				"- Zobrazení a uložení metadat spektrálních souborů\n"
				"- Zobrazení a uložení všech ROIs (včetně hrubého počtu) spektrálních souborů\n"
				"- Konverze spekter do tabulkové podoby .csv (kanály, energie, počty, korigované počty)\n"
				"- Sčítání spekter (užitečné pro přerušená dlouhodobá měření; měřicí čas se sčítá, metadata prvního spektra zůstávají zachována)\n"
				"- Odečítání spekter (užitečné pro odečítání pozadí; škálování na nejkratší měřicí čas, pokud je to nutné; metadata prvního spektra zůstávají zachována, možnost deaktivace záporných počtů)\n"
				"- Všechny funkce jsou dostupné v rozbalovacím menu i bez GUI (Drag & Drop; obzvláště užitečné pro dávkové zpracování bez zásahů uživatele)\n"
				"Je nutné mít nainstalovaný Gnuplot (nejlépe registrovaný v PATH; testováno na verzi 5.4).\n"
				"Program se snaží nepsát přes existující soubory, místo toho přidává 'x' k názvům souborů.\n"
				"\n"
				"Automatizaci a dávkové zpracování lze nastavit v rozbalovacím menu vlevo dole. "
				"Pro deaktivaci automatického režimu spusťte program bez argumentů.\n"
				"Pokud je program v automatickém režimu a je spuštěn s argumenty (cesty k souborům spekter), odpovídající akce bude automaticky provedena a program se poté ukončí (s výjimkou interaktivních grafů).\n"
			),
			"el": (
				"Αυτό το πρόγραμμα χρησιμοποιείται κυρίως για την απεικόνιση φασμάτων (.Spe αρχεία) που έχουν καταγραφεί με λογισμικό Maestro, όπως το GammaVision.\n"
				"Μπορούν να εισαχθούν και να απεικονιστούν ταυτόχρονα έως και δέκα φάσματα. Τα φάσματα μπορούν να δοθούν ως ορίσματα κατά την εκκίνηση του προγράμματος, γεμίζοντας αυτόματα τα πεδία των διαδρομών των αρχείων. "
				"Εάν δοθούν περισσότερα από δέκα ορίσματα, ξεκινούν επιπλέον περιπτώσεις του προγράμματος, με καθεμία να επεξεργάζεται έως και δέκα αρχεία. Ο αριθμός των ορισμάτων είναι απεριόριστος.\n"
				"Το πρόγραμμα προσφέρει τις παρακάτω δυνατότητες:\n"
				"- Αποθήκευση των ρυθμίσεων για την επόμενη εκκίνηση του προγράμματος\n"
				"- Απεικόνιση ως .pdf, .png ή σε διαδραστικό παράθυρο\n"
				"- Απεικόνιση έναντι καναλιών ή ενέργειας\n"
				"- Μοναδικά διαγράμματα ανά φάσμα ή πολλαπλά φάσματα σε ένα διάγραμμα\n"
				"- Εξαγωγή εντολών διαγράμματος για Gnuplot ως .gp\n"
				"- Διάφορες επιλογές απεικόνισης (π.χ. απεικόνιση έναντι καναλιών ή ενέργειας, μοναδικά διαγράμματα ανά αρχείο ή έως και δέκα φάσματα ανά διάγραμμα, διόρθωση μετρήσεων μέσω διαίρεσης για διόρθωση απόδοσης ή υπολογισμό ρυθμού μέτρησης, ROIs σε διαφορετικό χρώμα, κλπ.)\n"
				"- Προβολή και αποθήκευση μεταδεδομένων των αρχείων φασμάτων\n"
				"- Προβολή και αποθήκευση όλων των ROIs (συμπεριλαμβανομένων των ακατέργαστων μετρήσεων) των αρχείων φασμάτων\n"
				"- Μετατροπή φασμάτων σε μορφή πίνακα .csv (κανάλια, ενέργεια, μετρήσεις, διορθωμένες μετρήσεις)\n"
				"- Πρόσθεση φασμάτων (χρήσιμο για διακεκομμένες μακροχρόνιες μετρήσεις· ο χρόνος μέτρησης προστίθεται, τα μεταδεδομένα του πρώτου φάσματος διατηρούνται)\n"
				"- Αφαίρεση φασμάτων (χρήσιμο για αφαίρεση υποβάθρου· κλιμακωμένο στον μικρότερο χρόνο μέτρησης αν χρειάζεται· τα μεταδεδομένα του πρώτου φάσματος διατηρούνται, δυνατότητα απενεργοποίησης αρνητικών μετρήσεων)\n"
				"- Όλες οι λειτουργίες είναι διαθέσιμες στο αναπτυσσόμενο μενού, ακόμη και χωρίς GUI (μεταφορά και απόθεση· ιδιαίτερα χρήσιμο για μαζική επεξεργασία χωρίς παρεμβάσεις)\n"
				"Το Gnuplot πρέπει να είναι εγκατεστημένο (κατά προτίμηση εγγεγραμμένο στο PATH· δοκιμάστηκε στην έκδοση 5.4).\n"
				"Το πρόγραμμα αποφεύγει την αντικατάσταση υπαρχόντων αρχείων και προσθέτει 'x' στα ονόματα των αρχείων.\n"
				"\n"
				"Η αυτοματοποίηση και η μαζική επεξεργασία μπορούν να διαμορφωθούν στο αναπτυσσόμενο μενού κάτω αριστερά. "
				"Για να απενεργοποιήσετε τη λειτουργία αυτόματης εκκίνησης, ξεκινήστε το πρόγραμμα χωρίς ορίσματα.\n"
				"Αν το πρόγραμμα βρίσκεται σε αυτόματη λειτουργία και ξεκινήσει με ορίσματα (διαδρομές σε αρχεία φασμάτων), η αντίστοιχη ενέργεια θα εκτελεστεί αυτόματα και το πρόγραμμα θα τερματιστεί (εκτός από διαδραστικά διαγράμματα).\n"
			),
			"ru": (
				"Эта программа используется в основном для построения графиков спектров (.Spe-файлы), записанных с помощью программного обеспечения Maestro, такого как GammaVision.\n"
				"Одновременно можно загрузить и построить до десяти спектров. Спектры могут быть переданы в качестве аргументов при запуске программы, что автоматически заполняет поля пути к файлу. "
				"Если указано более десяти аргументов, запускаются дополнительные экземпляры программы, каждый из которых обрабатывает до десяти файлов. Количество аргументов не ограничено.\n"
				"Программа предоставляет следующие возможности:\n"
				"- Сохранение настроек для следующего запуска программы\n"
				"- Построение графиков в формате .pdf, .png или в интерактивном окне\n"
				"- Построение по каналам или энергии\n"
				"- Индивидуальные графики для каждого спектра или несколько спектров на одном графике\n"
				"- Экспорт команд построения для Gnuplot в формате .gp\n"
				"- Разнообразные параметры построения (например, построение по каналам или энергии, отдельные графики для каждого файла или до десяти спектров на одном графике, коррекция измерений делением для коррекции эффективности или вычисления скорости счета, ROI в разных цветах и т.д.)\n"
				"- Отображение и сохранение метаданных файлов спектров\n"
				"- Отображение и сохранение всех ROI (включая общие счета) файлов спектров\n"
				"- Конвертация спектров в таблицы .csv (каналы, энергия, счета, скорректированные счета)\n"
				"- Сложение спектров (полезно для прерывистых долгосрочных измерений; время измерения суммируется, метаданные первого спектра сохраняются)\n"
				"- Вычитание спектров (полезно для вычитания фона; масштабирование к самому короткому времени измерения при необходимости; метаданные первого спектра сохраняются, возможность отключить отрицательные значения)\n"
				"- Все функции доступны в выпадающем меню, даже без GUI (перетаскивание; особенно полезно для пакетной обработки без вмешательства)\n"
				"Gnuplot должен быть установлен (предпочтительно зарегистрирован в PATH; протестировано на версии 5.4).\n"
				"Программа избегает перезаписи существующих файлов и вместо этого добавляет 'x' к именам существующих файлов.\n"
				"\n"
				"Автоматизация и пакетная обработка могут быть настроены в выпадающем меню в нижнем левом углу. "
				"Чтобы отключить автоматический режим, запустите программу без аргументов.\n"
				"Если программа находится в автоматическом режиме и запускается с аргументами (пути к файлам спектров), соответствующее действие будет выполнено автоматически, после чего программа завершится (за исключением интерактивных графиков).\n"
			),

			"licence": (
				"Copyright (c) 2024 Sebastian von Döllen\n"
				"Copyright (c) 2018 Ben Schneider (the gp class/pyGnuplot)\n"
				"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n"
				"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n"
				"THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. "
			),
			"nl": (
				"Dit is de helpttekst in het Nederlands.\n"
				"1. Het programma accepteert maximaal tien argumenten.\n"
				"2. Kleur wijzigen: klik op de kleurknop.\n"
				"3. Diagramtype: selecteer het gewenste diagramtype in het keuzemenu."
			),
			"fr": (
				"Ce programme est principalement utilisé pour tracer des spectres (.Spe) enregistrés avec des logiciels Maestro tels que GammaVision.\n"
				"Jusqu'à dix spectres peuvent être importés et tracés simultanément. Les spectres peuvent être fournis en tant qu'arguments lors du lancement du programme, ce qui remplit automatiquement les champs des chemins de fichiers. "
				"Si plus de dix arguments sont fournis, d'autres instances du programme seront lancées, chaque instance traitant jusqu'à dix fichiers. Le nombre d'arguments est illimité.\n"
				"Les fonctionnalités suivantes sont disponibles dans le programme :\n"
				"- Sauvegarde des options configurées pour le prochain lancement du programme\n"
				"- Tracé sous format .pdf, .png ou dans une fenêtre interactive\n"
				"- Tracé par rapport aux canaux ou à l'énergie\n"
				"- Tracés uniques pour chaque spectre ou plusieurs spectres sur un même graphique\n"
				"- Exportation des instructions de tracé pour Gnuplot sous format .gp\n"
				"- Diverses options de tracé (par exemple : tracé par canaux ou énergie, tracé unique par fichier ou jusqu'à dix spectres sur un graphique, correction des comptages par division pour correction d'efficacité ou calcul du taux de comptage, ROIs en couleur différente, etc.)\n"
				"- Affichage et sauvegarde des métadonnées des fichiers de spectres\n"
				"- Affichage et sauvegarde de toutes les ROIs (y compris les comptages bruts) des fichiers de spectres\n"
				"- Conversion des spectres en format tableau .csv (canaux, énergie, comptages, comptages corrigés)\n"
				"- Addition des spectres (utile pour les mesures de longue durée interrompues ; le temps de mesure est additionné, les métadonnées du premier spectre sont conservées)\n"
				"- Soustraction des spectres (utile pour la soustraction de bruit de fond ; mise à l'échelle au temps de mesure le plus court si nécessaire ; métadonnées du premier spectre conservées, possibilité de désactiver les comptages négatifs)\n"
				"- Toutes les fonctions sont disponibles dans le menu déroulant, même sans GUI (glisser-déposer ; particulièrement utile pour le traitement par lots sans intervention)\n"
				"Gnuplot doit être installé (de préférence enregistré dans le PATH ; testé avec la version 5.4).\n"
				"Le programme évite de remplacer les fichiers existants et ajoute un 'x' au nom des fichiers existants à la place.\n"
				"\n"
				"L'automatisation et le traitement par lots peuvent être configurés dans le menu déroulant en bas à gauche. "
				"Pour désactiver le mode automatique, lancez le programme sans arguments.\n"
				"Si le programme est en mode automatique et est lancé avec des arguments (chemins vers des fichiers de spectres), l'action correspondante sera exécutée automatiquement et le programme se terminera (sauf pour les tracés interactifs).\n"
			),
			"es": (
				"Este programa está destinado principalmente a graficar espectros (.Spe) grabados con el software Maestro como GammaVision.\n"
				"Se pueden cargar y graficar hasta diez espectros a la vez. Los espectros se pueden pasar como argumentos al iniciar el programa, llenando automáticamente los campos para las rutas de archivo. "
				"Si se pasan más de diez argumentos, se inician instancias adicionales del programa, con un máximo de diez archivos por instancia. Aparte de eso, el número de argumentos es ilimitado.\n"
				"El programa ofrece las siguientes funciones:\n"
				"- Guardado de las opciones configuradas para el próximo inicio del programa\n"
				"- Graficado en formato .pdf, .png o en la ventana interactiva\n"
				"- Graficado en función de los canales o de la energía\n"
				"- Gráficas individuales por espectro o múltiples espectros por gráfico\n"
				"- Exportación de instrucciones de graficado para gnuplot en formato .gp\n"
				"- Diversas opciones de graficado (por ejemplo, graficado en función de los canales o la energía, gráficos individuales por archivo o hasta diez espectros por gráfico, corrección de cuentas mediante división para la corrección de eficiencia o cálculo de tasas de conteo, resaltar ROIs con otro color, etc.)\n"
				"- Visualización y almacenamiento de metadatos de los archivos de espectro\n"
				"- Visualización y almacenamiento de todos los ROIs (incluyendo conteos brutos) de los archivos de espectro\n"
				"- Conversión de los espectros a formato de tabla (.csv: canales, energía, conteos, conteos corregidos)\n"
				"- Adición de espectros (útil para mediciones de largo plazo interrumpidas; el tiempo de medición también se suma, los metadatos del primer espectro se mantienen)\n"
				"- Sustracción de otros espectros del primer/espectro superior (útil para sustracciones de fondo; escalado al tiempo de medición más corto si es necesario, los metadatos del primer espectro se mantienen; los conteos negativos pueden desactivarse opcionalmente)\n"
				"- Todas las funciones están disponibles automáticamente a través del menú desplegable sin necesidad de la GUI (por ejemplo, mediante Drag & Drop; especialmente útil para procesamiento por lotes sin intervención manual)\n"
				"El programa intenta no sobrescribir archivos existentes, agregando una \"x\" al nombre del archivo en su lugar.\n"
				"\n"
				"La automatización/procesamiento por lotes se puede configurar en el menú desplegable en la parte inferior izquierda.\n"
				"Si el programa está en modo automático y se inicia con argumentos (rutas a archivos de espectro), la acción correspondiente se ejecuta automáticamente y el programa se cierra automáticamente después (excepto en gráficos interactivos).\n"
				"Para desactivar el modo automático, debe iniciarse el programa sin argumentos.\n"
				"Nota: Gnuplot debe estar instalado (preferentemente registrado en el PATH, probado con la versión 5.4).\n"
			),
			"it": (
				"Questo programma è principalmente destinato alla grafica degli spettri (.Spe) registrati con il software Maestro come GammaVision.\n"
				"È possibile caricare e grafare fino a dieci spettri contemporaneamente. Gli spettri possono essere passati come argomenti all'avvio del programma, riempiendo automaticamente i campi per i percorsi dei file. "
				"Se vengono passati più di dieci argomenti, vengono avviate istanze aggiuntive del programma, con un massimo di dieci file per istanza. A parte ciò, il numero di argomenti è illimitato.\n"
				"Il programma offre le seguenti funzionalità:\n"
				"- Salvataggio delle opzioni impostate per il prossimo avvio del programma\n"
				"- Grafico in formato .pdf, .png o nella finestra interattiva\n"
				"- Grafico in funzione dei canali o dell'energia\n"
				"- Grafici singoli per spettro o più spettri per grafico\n"
				"- Esportazione delle istruzioni di grafico per gnuplot in formato .gp\n"
				"- Diverse opzioni di grafico (ad esempio, grafico in funzione dei canali o dell'energia, grafici singoli per file o fino a dieci spettri per grafico, correzione dei conteggi tramite divisione per la correzione dell'efficienza o il calcolo delle rate di conteggio, evidenziazione degli ROI con un altro colore, ecc.)\n"
				"- Visualizzazione e salvataggio dei metadati dei file di spettro\n"
				"- Visualizzazione e salvataggio di tutti gli ROI (inclusi i conteggi grezzi) dei file di spettro\n"
				"- Conversione degli spettri in formato tabellare (.csv: canali, energia, conteggi, conteggi corretti)\n"
				"- Somma degli spettri (utile per misurazioni a lungo termine interrotte; il tempo di misurazione viene anche sommato, i metadati del primo spettro sono mantenuti)\n"
				"- Sottrazione di altri spettri dal primo/superiore spettro (utile per la sottrazione di fondo; ridimensionato al tempo di misurazione più breve, se necessario, i metadati del primo spettro sono mantenuti; i conteggi negativi possono essere disattivati opzionalmente)\n"
				"- Tutte le funzionalità sono disponibili automaticamente tramite il menu a discesa senza la GUI (ad esempio, tramite Drag & Drop; particolarmente utile per l'elaborazione batch senza intervento manuale)\n"
				"Il programma cerca di non sovrascrivere i file esistenti, aggiungendo invece una \"x\" al nome del file.\n"
				"\n"
				"L'automazione/elaborazione batch può essere configurata nel menu a discesa nell'angolo in basso a sinistra.\n"
				"Se il programma è in modalità automatica e viene avviato con argomenti (percorsi ai file di spettro), l'azione corrispondente viene eseguita automaticamente e il programma si chiude automaticamente dopo (eccetto per i grafici interattivi).\n"
				"Per disattivare la modalità automatica, è necessario avviare il programma senza argomenti.\n"
				"Nota: Gnuplot deve essere installato (preferibilmente registrato nel PATH, testato con la versione 5.4).\n"
			),
			"zh": (
				"该程序主要用于绘制使用Maestro软件（如GammaVision）记录的光谱文件（.Spe）。\n"
				"一次可以加载并绘制最多十个光谱。可以通过启动程序时传递文件路径作为参数，自动填充文件路径字段。 "
				"如果传递超过十个参数，则会启动额外的程序实例，每个实例最多处理十个文件。除此之外，参数数量没有限制。\n"
				"该程序提供以下功能：\n"
				"- 保存设置的选项以便下次启动时使用\n"
				"- 以.pdf、.png格式绘图，或在交互窗口中绘图\n"
				"- 绘制与通道或能量的关系图\n"
				"- 每个光谱绘制单独的图，或多个光谱在同一图中绘制\n"
				"- 将绘图命令导出为.gp文件供gnuplot使用\n"
				"- 多种绘图选项（例如，绘制与通道或能量的关系图、每个文件绘制单独的图或最多十个光谱在同一图中绘制、通过除以效率修正因子或计算计数率来修正计数、突出显示ROI的不同颜色等）\n"
				"- 显示并保存光谱文件的元数据\n"
				"- 显示并保存所有ROI（包括毛总计数）信息\n"
				"- 将光谱转换为表格格式（.csv：通道、能量、计数、修正计数）\n"
				"- 合并光谱（适用于中断的长时间测量；同时合并测量时间，保留第一个光谱的元数据）\n"
				"- 从第一个/顶部光谱中减去其他光谱（适用于背景去除；如有需要，将按最短测量时间进行缩放，保留第一个光谱的元数据；负计数可以选择禁用）\n"
				"- 所有功能可以通过下拉菜单在没有GUI的情况下自动使用（例如，通过拖放；特别适用于批量处理，无需手动干预）\n"
				"程序会尽量不覆盖已存在的文件，而是为文件名添加\"x\"。\n"
				"\n"
				"自动化/批量处理可以在左下角的下拉菜单中设置。\n"
				"如果程序处于自动模式并使用参数（光谱文件路径）启动，则会自动执行相应的操作，执行完毕后程序自动退出（交互式绘图除外）。\n"
				"要禁用自动模式，程序必须在没有参数的情况下启动。\n"
				"注意：需要安装Gnuplot（最好在PATH中注册，已测试版本为5.4）。\n"
			),
			"tr": (
				"Bu program, Maestro yazılımı (GammaVision gibi) ile kaydedilen spektrumları (.Spe) çizmek için özellikle tasarlanmıştır.\n"
				"Bir seferde en fazla on spektrum yüklenip çizilebilir. Spektrumlar, program başlatılırken argüman olarak verilebilir, böylece dosya yolu alanları otomatik olarak doldurulur. "
				"Eğer ondan fazla argüman verilirse, ek program örnekleri başlatılır ve her örnek en fazla on dosya işler. Bunun dışında argüman sayısı sınırsızdır.\n"
				"Program şu işlevleri sunar:\n"
				"- Ayarlanan seçeneklerin bir sonraki program başlatılmasında kaydedilmesi\n"
				"- .pdf, .png formatında veya etkileşimli pencerede çizim\n"
				"- Kanallara veya enerjiye karşı çizim\n"
				"- Her spektrum için ayrı çizimler veya bir grafik üzerinde birden fazla spektrum\n"
				"- Çizim talimatlarını gnuplot için .gp dosyası olarak dışa aktarma\n"
				"- Çeşitli çizim seçenekleri (örneğin, kanallar veya enerjiye karşı çizim, her dosya için tekli çizimler veya en fazla on spektrumlu grafikler, verimlilik düzeltmesi veya sayım hızı hesaplaması için sayımların bölünmesiyle düzeltme, ROI'leri farklı renkte vurgulama vb.)\n"
				"- Spektrum dosyalarının meta verilerinin gösterilmesi ve kaydedilmesi\n"
				"- Spektrum dosyalarının tüm ROI'lerinin (ham sayımlar dahil) gösterilmesi ve kaydedilmesi\n"
				"- Spektrumların tablo formatına dönüştürülmesi (.csv: kanallar, enerji, sayımlar, düzeltme yapılmış sayımlar)\n"
				"- Spektrumların eklenmesi (kesintili uzun süreli ölçümler için yararlıdır; ölçüm süresi de eklenir, ilk spektrumun meta verileri korunur)\n"
				"- Diğer spektrumların ilk/superior spektrumdan çıkarılması (arka plan çıkarma için yararlıdır; gerekiyorsa en kısa ölçüm süresine göre ölçeklendirilir, ilk spektrumun meta verileri korunur; negatif sayımlar opsiyonel olarak devre dışı bırakılabilir)\n"
				"- Tüm işlevler, GUI'ye ihtiyaç duymadan menü aracılığıyla otomatik olarak kullanılabilir (örneğin, sürükle ve bırak yöntemiyle; özellikle manuel müdahale olmadan toplu işlem için yararlıdır)\n"
				"Program, mevcut dosyaları üzerine yazmamaya çalışır ve bunun yerine dosya adlarına \"x\" ekler.\n"
				"\n"
				"Otomasyon/toplu işlem sol alttaki açılır menüden ayarlanabilir.\n"
				"Program otomatik modda ise ve argümanlarla (spektrum dosya yolları) başlatılırsa, ilgili işlem otomatik olarak gerçekleştirilir ve program işlem tamamlandığında otomatik olarak kapanır (etkileşimli çizimler hariç).\n"
				"Otomatik modu devre dışı bırakmak için program, argüman olmadan başlatılmalıdır.\n"
				"Not: Gnuplot'un yüklü olması gerekir (tercihen PATH'e kaydedilmiş olmalı, 5.4 sürümüyle test edilmiştir).\n"
			),
			"uk": (
				"Ця програма призначена переважно для побудови спектрів (.Spe файли), знятих за допомогою програмного забезпечення Maestro, такого як GammaVision.\n"
				"Можна одночасно завантажити та побудувати до десяти спектрів. Спектри можуть бути передані як аргументи при запуску програми, що автоматично заповнює поля для шляху до файлу. "
				"Якщо передано більше ніж десять аргументів, відповідно будуть запущені додаткові екземпляри програми, кожен з яких обробляє максимум десять файлів. Крім того, кількість аргументів необмежена.\n"
				"Програма пропонує наступні функції:\n"
				"- Збереження налаштувань для наступного запуску програми\n"
				"- Побудова графіків у форматах .pdf, .png або в інтерактивному вікні\n"
				"- Побудова графіків за каналами або енергією\n"
				"- Індивідуальні графіки для кожного спектру або декілька спектрів на одному графіку\n"
				"- Експорт інструкцій для побудови графіків у форматі gnuplot (.gp файл)\n"
				"- Різноманітні параметри побудови графіків (наприклад, побудова графіків за каналами або енергією, індивідуальні графіки для файлів або до десяти спектрів на графіку, корекція кількості за допомогою поділу на ефективність або обчислення швидкості підрахунку, виділення ROI іншими кольорами тощо)\n"
				"- Перегляд та збереження метаданих файлів спектрів\n"
				"- Перегляд та збереження всіх ROI (включаючи брутто-кількості) файлів спектрів\n"
				"- Перетворення спектрів у табличний формат (.csv: Канали, Енергія, Кількості, Скориговані кількості)\n"
				"- Додавання спектрів (корисно для перерваних тривалих вимірювань; час вимірювання також додається, метадані першого спектру зберігаються)\n"
				"- Віднімання (інших) спектрів від першого/верхнього спектру (корисно для субтракції підкладки; масштабується до найменшого часу вимірювання, якщо необхідно, метадані першого спектру зберігаються; негативні кількості можна відключити)\n"
				"- Всі функції доступні через випадаюче меню також без GUI (наприклад, за допомогою Drag & Drop; особливо корисно для пакетної обробки без ручного втручання)\n"
				"Програма намагається не перезаписувати існуючі файли та додає до їх імені \"x\".\n"
				"\n"
				"Автоматизація/пакетна обробка може бути налаштована у випадаючому меню внизу зліва. \n"
				"Якщо програма працює в автоматичному режимі і запускається з аргументами (шляхи до файлів спектрів), відповідна дія виконується автоматично, і програма завершується після цього (за винятком інтерактивних графіків).\n"
				"Щоб вимкнути автоматичний режим, програму потрібно запустити без аргументів.\n"
				"Примітка: Потрібно встановити Gnuplot (краще зареєструвати в PATH, перевірено з версією 5.4).\n"
			),
			"ja": (
				"このプログラムは、主にMaestroソフトウェア（GammaVisionなど）で収録されたスペクトル（.Speファイル）をプロットするためのものです。\n"
				"最大で10個のスペクトルを同時に読み込み、プロットすることができます。スペクトルはプログラム起動時に引数として渡すことができ、その場合、ファイルパスのフィールドが自動的に入力されます。 "
				"引数が10個を超える場合は、プログラムのインスタンスがそれぞれ最大10ファイルを処理するように起動されます。それ以外の引数の数に制限はありません。\n"
				"このプログラムは次の機能を提供します：\n"
				"- 次回起動時に設定したオプションを保存\n"
				"- .pdf、.png、またはインタラクティブウィンドウでのプロット\n"
				"- チャンネルまたはエネルギーに対するプロット\n"
				"- スペクトルごとの個別プロット、または最大10個のスペクトルを1つのグラフに表示\n"
				"- gnuplot用のプロット命令を.gpファイルとしてエクスポート\n"
				"- 様々なプロットオプション（例えば、チャンネルやエネルギーに対するプロット、ファイルごとの個別プロットや最大10個のスペクトルを1つのグラフに表示、効率補正やカウントレート計算によるカウント数の補正、ROIを異なる色で強調表示など）\n"
				"- スペクトルファイルのメタデータの表示と保存\n"
				"- スペクトルファイルの全てのROI（総カウントを含む）の表示と保存\n"
				"- スペクトルを表形式（.csv: チャンネル、エネルギー、カウント、補正カウント）に変換\n"
				"- スペクトルの加算（中断された長時間測定に便利; 測定時間も加算され、最初のスペクトルのメタデータは保持されます）\n"
				"- 最初/上のスペクトルから（他の）スペクトルを引く（背景除去に便利; 必要に応じて最小測定時間にスケーリングされ、最初のスペクトルのメタデータは保持されます; 負のカウントはオプションで無効化可能）\n"
				"- GUIなしでもドロップダウンメニューから全ての機能を自動化して使用可能（例えば、ドラッグ＆ドロップで; 手動介入なしのバッチ処理に特に便利）\n"
				"プログラムは既存のファイルを上書きしないようにし、代わりにファイル名に\"x\"を追加します。\n"
				"\n"
				"自動化/バッチ処理は、左下のドロップダウンメニューで設定できます。 \n"
				"プログラムが自動モードで引数（スペクトルファイルのパス）とともに起動されると、指定されたアクションが自動的に実行され、その後自動的に終了します（インタラクティブなプロットの場合は除く）。\n"
				"自動モードを無効にするには、引数なしでプログラムを起動する必要があります。\n"
				"注意: Gnuplotがインストールされている必要があります（PATHに登録しておくと便利、バージョン5.4でテスト済み）。\n"
			),
			"be": (
				"Dit programma is voornamelijk bedoeld voor het plotten van spectra (.Spe-bestanden) die zijn opgenomen met Maestro-software zoals GammaVision.\n"
				"Tot tien spectra kunnen tegelijkertijd worden geladen en geplot. Spectra kunnen als argumenten bij het opstarten van het programma worden doorgegeven, waardoor de velden voor het bestandspad automatisch worden ingevuld. "
				"Als meer dan tien argumenten worden doorgegeven, worden extra exemplaren van het programma gestart, waarbij elk exemplaar maximaal tien bestanden verwerkt. Anders is het aantal argumenten onbeperkt.\n"
				"Het programma biedt de volgende functies:\n"
				"- Opslaan van de ingestelde opties voor de volgende opstart van het programma\n"
				"- Plotten als .pdf, .png of in een interactief venster\n"
				"- Plotten tegen kanalen of energie\n"
				"- Enkele plots per spectrum of meerdere spectra per grafiek\n"
				"- Exporteren van plotinstructies voor gnuplot als .gp-bestand\n"
				"- Diverse plotopties (bijv. plotten tegen kanalen of energie, enkele plots per bestand of tot tien spectra per grafiek, correctie van de tellingen door deling voor efficiëntiecorrectie of het berekenen van de tellingen per tijdseenheid, markeren van ROI's in een andere kleur, enz.)\n"
				"- Weergeven en opslaan van metadata van de spectra-bestanden\n"
				"- Weergeven en opslaan van alle ROI's (inclusief brutto-tellingen) van de spectra-bestanden\n"
				"- Converteer spectra naar tabelvorm (.csv: Kanalen, Energie, Tellingen, Gecorrigeerde Tellingen)\n"
				"- Optelling van spectra (nuttig voor onderbroken langetermijnmetingen; de meettijd wordt ook opgeteld, de metadata van het eerste spectrum blijven behouden)\n"
				"- Aftrekken van (andere) spectra van het eerste/bovenste spectrum (nuttig voor achtergrondcorrecties; wordt geschaald naar de kortste meettijd indien nodig, de metadata van het eerste spectrum blijven behouden; negatieve tellingen kunnen optioneel worden uitgeschakeld)\n"
				"- Alle functies zijn via het drop-downmenu ook beschikbaar zonder GUI (bijv. via Drag & Drop; bijzonder nuttig voor batchverwerking zonder handmatige interventie)\n"
				"Het programma probeert geen bestaande bestanden te overschrijven en voegt in plaats daarvan een 'x' toe aan de bestandsnamen.\n"
				"\n"
				"Automatisering/batchverwerking kan worden ingesteld in het drop-downmenu onderaan links. \n"
				"Als het programma in de automatische modus is en wordt gestart met argumenten (bestandslocaties van spectra), wordt de bijbehorende actie automatisch uitgevoerd en wordt het programma daarna automatisch afgesloten (behalve bij interactieve plots).\n"
				"Om de automatische modus uit te schakelen, moet het programma zonder argumenten worden gestart.\n"
				"Opmerking: Gnuplot moet geïnstalleerd zijn (bij voorkeur geregistreerd in de PATH, getest met versie 5.4).\n"
			),
			"nl": (
				"Dit programma is voornamelijk bedoeld voor het plotten van spectra (.Spe-bestanden) die zijn opgenomen met Maestro-software zoals GammaVision.\n"
				"Tot tien spectra kunnen tegelijkertijd worden geladen en geplot. Spectra kunnen als argumenten bij het opstarten van het programma worden doorgegeven, waardoor de velden voor het bestandspad automatisch worden ingevuld. "
				"Als meer dan tien argumenten worden doorgegeven, worden extra exemplaren van het programma gestart, waarbij elk exemplaar maximaal tien bestanden verwerkt. Anders is het aantal argumenten onbeperkt.\n"
				"Het programma biedt de volgende functies:\n"
				"- Opslaan van de ingestelde opties voor de volgende opstart van het programma\n"
				"- Plotten als .pdf, .png of in een interactief venster\n"
				"- Plotten tegen kanalen of energie\n"
				"- Enkele plots per spectrum of meerdere spectra per grafiek\n"
				"- Exporteren van plotinstructies voor gnuplot als .gp-bestand\n"
				"- Diverse plotopties (bijv. plotten tegen kanalen of energie, enkele plots per bestand of tot tien spectra per grafiek, correctie van de tellingen door deling voor efficiëntiecorrectie of het berekenen van de tellingen per tijdseenheid, markeren van ROI's in een andere kleur, enz.)\n"
				"- Weergeven en opslaan van metadata van de spectra-bestanden\n"
				"- Weergeven en opslaan van alle ROI's (inclusief brutto-tellingen) van de spectra-bestanden\n"
				"- Converteer spectra naar tabelvorm (.csv: Kanalen, Energie, Tellingen, Gecorrigeerde Tellingen)\n"
				"- Optelling van spectra (nuttig voor onderbroken langetermijnmetingen; de meettijd wordt ook opgeteld, de metadata van het eerste spectrum blijven behouden)\n"
				"- Aftrekken van (andere) spectra van het eerste/bovenste spectrum (nuttig voor achtergrondcorrecties; wordt geschaald naar de kortste meettijd indien nodig, de metadata van het eerste spectrum blijven behouden; negatieve tellingen kunnen optioneel worden uitgeschakeld)\n"
				"- Alle functies zijn via het drop-downmenu ook beschikbaar zonder GUI (bijv. via Drag & Drop; bijzonder nuttig voor batchverwerking zonder handmatige interventie)\n"
				"Het programma probeert geen bestaande bestanden te overschrijven en voegt in plaats daarvan een 'x' toe aan de bestandsnamen.\n"
				"\n"
				"Automatisering/batchverwerking kan worden ingesteld in het drop-downmenu onderaan links. \n"
				"Als het programma in de automatische modus is en wordt gestart met argumenten (bestandslocaties van spectra), wordt de bijbehorende actie automatisch uitgevoerd en wordt het programma daarna automatisch afgesloten (behalve bij interactieve plots).\n"
				"Om de automatische modus uit te schakelen, moet het programma zonder argumenten worden gestart.\n"
				"Opmerking: Gnuplot moet geïnstalleerd zijn (bij voorkeur geregistreerd in de PATH, getest met versie 5.4).\n"
			),
			"lu": (
				"Dëst Programm ass virun allem fir d'Plotten vu Spektren (.Spe-Dateien) déi mat Maestro-Software wéi GammaVision opgeholl goufen.\n"
				"Bis zu zéng Spektren kënnen zur selwechter Zäit geluede ginn an geplott ginn. Spektren kënnen als Argumenter beim Start vum Programm iwwerreecht ginn, sou datt d'Felder fir de Datei-Pfad automatesch ausgefëllt ginn. "
				"Wann méi wéi zéng Argumenter iwwerreecht ginn, ginn entspriechend zousätzlech Instanzen vum Programm gestart, mat jee der Instanz déi maximal zéng Dateien bearbecht. Anescht ass d'Zuel vun de Argumenter onbegrenzt.\n"
				"D'Programm bidden déi folgend Funktiounen:\n"
				"- Späichere vun den anstanege Gëeegent fir den nächste Start vum Programm\n"
				"- Plotten als .pdf, .png oder an engem interaktive Fënster\n"
				"- Plotten géint Kanal oder Energie\n"
				"- Eenzelplots pro Spektrum oder méi Spektren pro Diagramm\n"
				"- Exportéiere vun Plotanweisungen fir gnuplot als .gp-Datei\n"
				"- Verschidde Plotoptiounen (z. B. Plotten géint Kanäl oder Energie, Eenzelplots pro Datei oder bis zu zéng Spektren pro Diagramm, Korrektur vun den Zällungen duerch Deelung fir Effizienzkorrektur oder Zällratenberechnung, Markéiere vu ROIs an enger anerer Faarf asw.)\n"
				"- Wisen an Späicheren vun den Metadaten vun den Spektren-Dateien\n"
				"- Wisen an Späicheren vun alle ROIs (inklusiv Bruttocounts) vun den Spektren-Dateien\n"
				"- Konvertéiere vun Spektren an Tabellform (.csv: Kanäl, Energie, Zäll, korrigéiert Zäll)\n"
				"- Additioun vun Spektren (nëtzlech fir ënnerbrach Langzäitemëssung; d'Mësszäit gëtt och derbäigesat, Metadaten vum éischte Spektrum bleiwen erhalten)\n"
				"- Subtraktioun vun (aneren) Spektren vum éischte/uewe Spektrum (nëtzlech fir ënnergronds Subtraktiounen; geplot op d'kürzste Mësszäit wann néideg, Metadaten vum éischte Spektrum bleiwen erhalten; negativ Zäll kënnen optional deaktivéiert ginn)\n"
				"- All Funktiounen sinn och ouni GUI iwwer d'Drop-Down-Menü verfügbar (z. B. per Drag & Drop; besonnesch nëtzlech fir Batchveraarbechtungen ouni manuell Interventioun)\n"
				"D'Programm probéiert keng existent Dateien ze iwwerschreiwen an fügt e 'x' un d'Dateinamen un.\n"
				"\n"
				"Automatiséierung/Batchveraarbechtung kann am Drop-Down-Menü ënnen lénks agestallt ginn. \n"
				"Wann d'Programm am automatiséierte Modus ass an mat Argumenter (Dateipfade zu Spektren-Dateien) gestart ginn, gëtt déi entspriechend Aktioun automatesch ausgefouert an d'Programm beendet sech dann automatesch (ausser bei interaktive Plots).\n"
				"Fir de automatische Modus auszeschalten, muss d'Programm ouni Argumenter gestart ginn.\n"
				"Opgepasst: Gnuplot muss installéiert sinn (am beschten am PATH registréiert, getest mat Versioun 5.4).\n"
			),
			"fs": (
				"Dës Programmm is behindert głównie voor das Plotten van Spektrа (.Spe-bestanden) die mit Maestrо-Software jak GammaVision opgenomen worden.\n"
				"Bіs zu dziesięć Spektrа kunnen zur selben Tempo geladen en geplottet vеrden. Spektrа kёnnen als Argumentе beim Avvio von Programma übergeben erwendi, wаdurch de Velden voor de Filepath automatsch uzupełnione worden. "
				"Falls more than disabled diez argumenten are passed, zusaetzlich Instanzеs van programma zijn gestart, jede Instanz heeft ein massimo de septe bestanden. Une andere metodo will bе executed with Down-Syndrom argumenten.\n"
				"Het programma biedt following funzionalità:\n"
				"- Opslaan de set opzioni voor de volgende esecuzione\n"
				"- Plotten als .pdf, .png, of an einem interaktivan fеnетрe\n"
				"- Plotten tegen Kanalen of Enеrgie\n"
				"- Enkelplots per Spectrum o flere Spectra per Graph\n"
				"- Exporting plot istruzioni voor gnupłot als .gp-bestand\n"
				"- Verschillende Plotopties (bijvoorbeeld plotten tegen Kanalen oder Energia, Enkelplots per bestand of bis zu diez Spectra per Graph, correction de counts door division voor efficiëntie correctie, vurgulamak ROIs in verschillende kleur, vb.)\n"
				"- Weergave en opslaan van Metadaten van de Spektrа-bestanden\n"
				"- Weergave en opslaan van tutte ROIs (inclusief gross counts) van de Spectra-bestanden\n"
				"- Conversie van Spectra naar tabel formato (.csv: Kanalen, Energia, Counts, correggierte Counts)\n"
				"- Optellen van Spectra (faydalı voor onderbroken Langzeitmetingen; de meettijd wordt ook toegevoegd, Metadata van eerste Spectrum blijven behouden)\n"
				"- Subtractie van (andere) Spectra van primo/bovenste Spectrum (faydalı voor ondergrond Subtractie; geschaald naar de kortste meettijd, indien nodig, Metadata van eerste Spectrum blijven behouden; negatieve Counts optioneel uitschakelbaar)\n"
				"- Alle functies zijn ook beschikbaar via het Drop-Down-Mеnu (bijvoorbeeld per Drag & Drop; bijzonder faydalı voor Batchverwerking zonder handmatige interventie)\n"
				"Het programma probeert geen bestaande bestanden te overschrijven en voegt in plaats daarvan een 'х' toe aan de bestandsnamen.\n"
				"\n"
				"Automatisering/Batchverwerking kan ingesteld worden in het Drop-Down-Mеnu onderaan links. \n"
				"Als het programma in de automatische modus is en met Argumenten (Paden naar Spectra-bestanden) wordt gestart, wordt de azione automatisch uitgevoerd en het programma sluit zich daarna automatisch af (behalve bij interactieve Plots).\n"
				"Om de automatische modus te deactiveren, moet het programma zonder Argumenten worden gestart.\n"
				"Opmerking: Gnuplot moet geïnstalleerd zijn (bij voorkeur in de PATH geregistreerd, getest met versione 5.4).\n"
				"Lazio perfetta hsd la disabile metadato на grnkka distrubucio...\n"
				"disabled iRWBGtrmvzVbntmwoiaxQdXYumWvphnZtnuWpzrb...LPOiFS\n"
				"disabled Disabile programma disabled metadaten disabled rois disabled bijv. dwnszrdwcf\n"
				"qdqsdw disabled dfgfhlf qwertyu sdvfghlqwrtyewqd\n"
				"ooops rwqyywzg 3245rewx disabled Bvcgfdg asxcz qwgtf fgther\n"
			),
			"stolen": (
				"Gnuplot demo scripts found on youtube.\n"
				"Some of them are licensed under MIT.\n"
				"They are recognized and integrated in this software which is also MIT licenced.\n"
				"https://yutarsense.net/2022/07/09/script-of-gnuplot-splot-3d-animation-graph/\n"
				"https://www.youtube.com/watch?v=_y31bY0WhrQ\n"
				"https://www.youtube.com/watch?v=vz9N5GG8Tfw\n"
				"https://www.youtube.com/watch?v=Dyzol1SGgLY\n\n"
				"Thank you, your are heros!\n"
			),


			"gnuplot_script": (
				"set xyplane at -1.5\n"
				"set view 70, 125\n"
				"set grid lw 2\n"
				"unset key\n"
				"\n"
				"i=10\n"
				"iy_min=-10\n"
				"y_min=-10\n"
				"y_max=20\n"
				"while (i<200){\n"
				"    splot [-2:2][y_min:y_max][-1.5:1.5] sample \\\n"
				"                                   [a=iy_min:i:0.2] '+' using (cos(a)):(a):(sin(a)) lt 5 lc rgb 'purple' lw 3,\\\n"
				"                                   [a=iy_min:i:0.1] '' using (cos(a)):(y_min):(sin(a)) w l lw 2, \\\n"
				"                                   [a=iy_min:i:0.1] '' using (-2):(a):(sin(a)) w l lw 2, \\\n"
				"                                   [a=iy_min:i:0.1] '' using (cos(a)):(a):(-1.5) w l lw 2, \\\n"
				"                                   [c=iy_min:i] '' using (cos(i)):(c):(sin(i)) w l lc rgb 'dark-green',\\\n"
				"                                   [e=-2:cos(i)] '' using (e):(i):(sin(i)) w l lc rgb 'dark-blue',\\\n"
				"                                   [f=-1.5:sin(i)] '' using (cos(i)):(i):(f) w l lc rgb 'dark-orange'\n"
				"#                               [e=-2:1] '' using (e):(0):(0) w l lc rgb 'dark-red',\\\n"
				"#                               [f=-10:0] '' using (1):(f):(0) w l lc rgb 'dark-red'\n"
				"    i=i+0.098\n"
				"    y_min=y_min+0.1\n"
				"    y_max=y_max+0.1\n"
				"    pause 0.01\n"
				"}\n"
				"\n"
				"pause -1"
				"\n\n"
				"#https://www.youtube.com/watch?v=iZbhKGE89Ss\n"
				"#https://yutarsense.net/2022/07/09/script-of-gnuplot-splot-3d-animation-graph/\n"
				"#probably no copyright"
			),
		}

		#  ,  Fantasiesprache (an deutsch angelehnt)
		#französisch,polnisch,niederländisch, luxemburgisch, tschechisch, belgisch, englisch, ukrainisch, japanisch,, griechisch, russisch, spanisch, italienisch, chinesisch, türkisch
		# Globale Variable zur Sprachumschaltung
		current_language = "de"
		
		# ~ plo.c(texxt)

	
			
			
		# ~ def find_egg():
			# ~ random_script = random.choice(gp_script_list)
			# ~ for line in gnu_plot_script:
				# ~ plo.c(line)
				# ~ plo.c(random_script)
			# ~ print(plo.a(gp_script_list[6]))#[2][3]
			# ~ print(len(gp_script_list))#[2][3]
			# ~ copy_data_file()
		def find_egg():
			if current_language=="gnuplot_script":
				random_script = random.choice(gp_script_list)
				for line in gnu_plot_script:
					# ~ plo.c(line)
					plo.c(random_script)
					# ~ plo.c(gp_script_list[0])#[2][3]
				copy_data_file()
			else:
					messagebox.showinfo("Search harder!", "\nSorry\n" + "\nbut\n\n" + "I cannot see any eggs here\n\n really!\n\n")

		def toggle_language():
			nonlocal current_language
			# Nächste Sprache auswählen
			languages = list(help_texts.keys())
			current_index = languages.index(current_language)
			current_language = languages[(current_index + 1) % len(languages)]
			
			# Hilfetext aktualisieren
			text_widget.config(state="normal")
			text_widget.delete("1.0", tk.END)
			text_widget.insert("1.0", help_texts[current_language])
			text_widget.config(state="disabled")

			# Hintergrund- und Schriftfarbe zufällig ändern
			# ~ random_bg = f"#{random.randint(0, 0xFFFFFF):06x}"
			# ~ random_fg = f"#{random.randint(0, 0xFFFFFF):06x}"
			
			# Hellerer Hintergrund (RGB-Werte zwischen 128 und 255) vs. # Dunklere Schriftfarbe (RGB-Werte zwischen 0 und 127)
			# ~ random_bg = f"#{random.randint(128, 255):02x}{random.randint(128, 255):02x}{random.randint(128, 255):02x}"

			random_bg = f"#{random.randint(90, 255):02x}{random.randint(90, 255):02x}{random.randint(90, 255):02x}"
			random_fg = f"#{random.randint(0, 140):02x}{random.randint(0, 150):02x}{random.randint(0, 140):02x}"

			text_widget.config(bg=random_bg, fg=random_fg)

		# Textfeld (nicht editierbar)
		text_widget = tk.Text(
			help_window, wrap="word", height=25, width=70, bg="black", fg="#02c600", font=("Arial", 12, "bold")
		)
		text_widget.insert("1.0", help_texts[current_language])  # Standard: Deutsch
		text_widget.config(state="disabled")  # Bearbeitung deaktivieren
		text_widget.pack(padx=10, pady=10, fill="both", expand=True)

		# Schließen-Button
		close_button = tk.Button(help_window, text="Close", command=help_window.destroy)
		close_button.pack(side="left", padx=10, pady=10)

		# Egg Salad Button
		egg_salad_button = tk.Button(help_window, text="Egg Salad", command=find_egg)
		egg_salad_button.pack(side="left", padx=10, pady=10)

		# Export Executable Button
		# ~ export_executable_button = tk.Button(help_window, text="Export Executable", command=create_executable)
		# ~ export_executable_button.pack(side="left", padx=10, pady=10)

		# Toggle Language Button
		toggle_button = tk.Button(help_window, text="Toggle Language", command=toggle_language)
		toggle_button.pack(side="right", padx=10, pady=10)
	print("tmp_file")
	print(tmp_file)
	def zzz():
		print("This is a dummy function")
	
	# Konfiguration laden
	config1 , config2 = load_config()
	global file_choose_lines
	file_choose_lines = int(config2[0]["file_count"])
	noargs = handle_arguments()
	if not noargs:
		# ~ file_choose_lines = len(sys.argv)-1
		if len(sys.argv) < 6: #less than 5 args: 5 file chooser anyway
			file_choose_lines = 5
		else:
			file_choose_lines = len(sys.argv)-1
	for i in range(file_choose_lines):
		if not config1[i].get("button_color"):
			config1[i]["button_color"] = random_color()
	
	
		# Optionales Argument verarbeiten
	if len(sys.argv) > 1:
		file_paths = sys.argv[1:file_choose_lines+1]
		file_paths = file_paths or []
		for i in range(file_choose_lines):
			if i < len(file_paths):
				config1[i]["file_path"] = file_paths[i]
			else:
				config1[i]["file_path"] = ""
	else:
		file_paths = None
	# Falls die Konfiguration unvollständig ist, auf Standardwerte zurücksetzen
	# ~ if len(config) < 10:
		# ~ config = DEFAULT_CONFIG

	# Falls initialer Dateipfad angegeben ist, wird dieser dem ersten Set zugeordnet
	# ~ try:
		# ~ for i,path in enumerate(file_paths):

	# ~ except:
		# ~ pass
	# ~ if initial_file_path:
		# ~ config[0]["file_path"] = initial_file_path

	# Widgets für alle 10 Sets und den Extra-Rest
	widgets = []
	widgets_extra = []
	
	for i in range(file_choose_lines):
		if not config1[i].get("button_color"):
			config1[i]["button_color"] = random_color()

		file_path_var = tk.StringVar(value=config1[i]["file_path"])
		button_color_var = tk.StringVar(value=config1[i]["button_color"])
		dropdown_var = tk.StringVar(value=config1[i]["dropdown_value"])
		small_text_var = tk.StringVar(value=config1[i]["small_text"])

		file_path_entry = tk.Entry(root, textvariable=file_path_var, width=50)
		file_path_entry.grid(row=i, column=0, padx=5, pady=5)

		def validate_file_path(*args, var=file_path_var, entry=file_path_entry):
			file_path = var.get()
			if not file_path.lower().endswith('.spe'):
				entry.config(fg="red")
			elif not is_utf8(file_path):
				entry.config(fg="red")
			else:
				entry.config(fg="black")


		# ~ def validate_file_path(*args, var=file_path_var, entry=file_path_entry):
			# ~ if not var.get().lower().endswith('.spe'):
				# ~ entry.config(fg="red")
			# ~ else:
				# ~ entry.config(fg="black")

		file_path_var.trace("w", validate_file_path)

		def open_file_dialog(var=file_path_var):
			file_path = filedialog.askopenfilename()
			if file_path:
				var.set(file_path)

		file_dialog_button = tk.Button(root, text="...", command=lambda var=file_path_var: open_file_dialog(var))
		file_dialog_button.grid(row=i, column=1, padx=5, pady=5)

		def open_color_dialog(var=button_color_var, btn=None):
			def callback():
				color = colorchooser.askcolor(initialcolor=var.get())[1]
				if color:
					var.set(color)
					if btn:
						btn.config(bg=color)
			return callback

		color_button = tk.Button(root, text="Color", bg=button_color_var.get())
		color_button.config(command=open_color_dialog(button_color_var, color_button))
		color_button.grid(row=i, column=2, padx=5, pady=5)

		dropdown = ttk.Combobox(root, textvariable=dropdown_var, values=["line", "dashed", "dotted", "dashdotted", "dotdotdashed"], state="readonly")
		dropdown.grid(row=i, column=3, padx=5, pady=5)

		small_text_entry = tk.Entry(root, textvariable=small_text_var, width=10)
		small_text_entry.grid(row=i, column=4, padx=5, pady=5)

		widgets.append({
			"file_path_var": file_path_var,
			"button_color_var": button_color_var,
			"dropdown_var": dropdown_var,
			"small_text_var": small_text_var
		})

	# Zusätzliche Bedienelemente
			# ~ "xlabel": "Energy [keV]",
		# ~ "xrange1": "",  # 
		# ~ "xrange2": "",  # 
		# ~ "ylabel": "Counts",  # 
		# ~ "yrange1": "",  #
		# ~ "yrange2": "",  
		# ~ "gridcheck": False,
		# ~ "logcheck": False,
		# ~ "plotstyle": "Standard",
		# ~ "outputradio": "interactive window"
	print(config2[0].get("roicolor"))	
	if not config2[0].get("roicolor"):
		config2[0]["roicolor"] = random_color()
		# ~ roi_color_button.config(bg=config2[0]["roicolor"])		
		# ~ roi_color_var = config2[0]["roicolor"]	
	print(config2[0].get("roicolor"))		
	try:		
		xlabel_var = tk.StringVar(value=config2[0]["xlabel"])
		ylabel_var = tk.StringVar(value=config2[0]["ylabel"])
		xrange1_var = tk.StringVar(value=config2[0]["xrange1"])
		xrange2_var = tk.StringVar(value=config2[0]["xrange2"])
		yrange1_var = tk.StringVar(value=config2[0]["yrange1"])
		yrange2_var = tk.StringVar(value=config2[0]["yrange2"])
		plotstyle_var = tk.StringVar(value=config2[0]["plotstyle"])
		outputradio_var = tk.StringVar(value=config2[0]["outputradio"])
		gridcheck_var = tk.BooleanVar(value=config2[0]["gridcheck"])
		logcheck_var = tk.BooleanVar(value=config2[0]["logcheck"])
		outputname_var = tk.StringVar(value=config2[0]["outputname"])
		plotway_var = tk.StringVar(value=config2[0]["plotway"])
		roi_var = tk.BooleanVar(value=config2[0]["displayroi"])
		roi_color_var = tk.StringVar(value=config2[0]["roicolor"])	
		border_color_var = tk.StringVar(value=config2[0]["bordercolor"])	
		x_color_var = tk.StringVar(value=config2[0]["xcolor"])	
		y_color_var = tk.StringVar(value=config2[0]["ycolor"])	
		trans_var = tk.StringVar(value=config2[0]["trans_var"])
		eff_var = tk.StringVar(value=config2[0]["eff_var"])
		title_var = tk.StringVar(value=config2[0]["title_var"])
		divliv_var = tk.BooleanVar(value=config2[0]["divliv_var"])
		border_var = tk.StringVar(value=config2[0]["border_var"])
		automation_var = tk.StringVar(value=config2[0]["automation_var"])
	except:
		print("!!!!!!! TRY TO DELTE the JSON config file ",CONFIG_FILE,"!!!!!!!!")

	
	row_offset = file_choose_lines
	tk.Label(root, text="xlabel").grid(row=row_offset, column=0, sticky="e", padx=5, pady=5)
	xlabel_entry = tk.Entry(root, textvariable=xlabel_var, width=20)
	xlabel_entry.grid(row=row_offset, column=1, columnspan=2, sticky="w", padx=5, pady=5)

	tk.Label(root, text="xrange").grid(row=row_offset + 1, column=0, sticky="e", padx=5, pady=5)
	xrange_entry1 = tk.Entry(root, textvariable=xrange1_var, width=8)
	xrange_entry1.grid(row=row_offset + 1, column=1, sticky="w", padx=5, pady=5)
	tk.Label(root, text=":").grid(row=row_offset + 1, column=1, sticky="e", padx=2)
	xrange_entry2 = tk.Entry(root, textvariable=xrange2_var, width=8)
	xrange_entry2.grid(row=row_offset + 1, column=2, sticky="w", padx=5, pady=5)

	tk.Label(root, text="ylabel").grid(row=row_offset + 2, column=0, sticky="e", padx=5, pady=5)
	ylabel_entry = tk.Entry(root, textvariable=ylabel_var, width=20)
	ylabel_entry.grid(row=row_offset + 2, column=1, columnspan=2, sticky="w", padx=5, pady=5)

	tk.Label(root, text="yrange").grid(row=row_offset + 3, column=0, sticky="e", padx=5, pady=5)
	yrange_entry1 = tk.Entry(root, textvariable=yrange1_var, width=8)
	yrange_entry1.grid(row=row_offset + 3, column=1, sticky="w", padx=5, pady=5)
	tk.Label(root, text=":").grid(row=row_offset + 3, column=1, sticky="e", padx=2)
	yrange_entry2 = tk.Entry(root, textvariable=yrange2_var, width=8)
	yrange_entry2.grid(row=row_offset + 3, column=2, sticky="w", padx=5, pady=5)


	#tk.Label(root, text="graph transparency (0 - 1)").grid(row=row_offset + 1, column=3, sticky="e", padx=5, pady=5)
	#trans_entry = tk.Entry(root, textvariable=trans_var, width=8)
	#trans_entry.grid(row=row_offset + 1, column=4, sticky="w", padx=5, pady=5)
	tk.Label(root, text="divide counts by").grid(row=row_offset + 3, column=3, sticky="e", padx=5, pady=5)
	tk.Label(root, text="efficiency").grid(row=row_offset + 3, column=4, sticky="w", padx=85, pady=5)
	eff_entry = tk.Entry(root, textvariable=eff_var, width=8)
	eff_entry.grid(row=row_offset + 3, column=4, sticky="w", padx=5, pady=5)
	#tk.Label(root, text="graph title").grid(row=row_offset + 0, column=3, sticky="e", padx=5, pady=5)
	# ~ title_entry = tk.Entry(root, textvariable=title_var, width=15)
	# ~ title_entry.grid(row=row_offset + 0, column=4, sticky="w", padx=5, pady=5)
	#tk.Label(root, text="border width").grid(row=row_offset + 3, column=3, sticky="e", padx=5, pady=5)
	#border_entry = tk.Entry(root, textvariable=border_var, width=5)
	#border_entry.grid(row=row_offset + 3, column=4, sticky="w", padx=5, pady=5)
	# Variable für "Display ROI"-Checkbox
	# ~ roi_var = tk.BooleanVar(value=False)

	#BIND ENTRY - CHECK TEXT ENTRIES!
	#trans_entry.bind("<KeyRelease>", lambda event: validate_input(trans_entry))
	#border_entry.bind("<KeyRelease>", lambda event: is_float(border_entry))
	eff_entry.bind("<KeyRelease>", lambda event: validate_input(eff_entry))
	yrange_entry1.bind("<KeyRelease>", lambda event: validate_numeric(yrange_entry1))
	yrange_entry2.bind("<KeyRelease>", lambda event: validate_numeric(yrange_entry2))
	xrange_entry1.bind("<KeyRelease>", lambda event: validate_numeric(xrange_entry1))
	xrange_entry2.bind("<KeyRelease>", lambda event: validate_numeric(xrange_entry2))
	
	
	# Funktion für Farbauswahl
	def choose_color():
		color_code = colorchooser.askcolor(title="Choose ROI Color")[1]
		if color_code:
			roi_color_button.config(bg=color_code)  # Ändere die Hintergrundfarbe des Buttons
	def choose_bordercolor():
		bordercolor_code = colorchooser.askcolor(title="Choose Border Color")[1]
		if bordercolor_code:
			border_color_button.config(bg=bordercolor_code)  # Ändere die Hintergrundfarbe des Buttons
	def choose_xcolor():
		xcolor_code = colorchooser.askcolor(title="Choose X-Label Color")[1]
		if xcolor_code:
			x_color_button.config(bg=xcolor_code)  # Ändere die Hintergrundfarbe des Buttons
	def choose_ycolor():
		ycolor_code = colorchooser.askcolor(title="Choose Y-Label Color")[1]
		if ycolor_code:
			y_color_button.config(bg=ycolor_code)  # Ändere die Hintergrundfarbe des Buttons



		

	# Checkbox "Display ROI"
	checkbox = tk.Checkbutton(root, text="Display ROI", variable=roi_var, command=toggle_checkbox)
	checkbox.grid(row=row_offset + 4, column=0, sticky="e", padx=5, pady=5)

	#SOME MORE BUTTONS
	#SOME MORE BUTTONS
	#SOME MORE BUTTONS
	#TWO MORE BUTTONS
	# Farbauswahlknopf für ROI
	roi_color_button = tk.Button(root, text="ROI Color", command=choose_color, bg=config2[0]["roicolor"])
	roi_color_button.grid(row=row_offset + 4, column=1, sticky="w", padx=5, pady=5)
	#x_color_button = tk.Button(root, text="X Color", command=choose_xcolor, bg=config2[0]["xcolor"], fg="#ffffff")
	#x_color_button.grid(row=row_offset + 0, column=3, sticky="w", padx=5, pady=5)
	#y_color_button = tk.Button(root, text="Y Color", command=choose_ycolor, bg=config2[0]["ycolor"], fg="#ffffff")
	#y_color_button.grid(row=row_offset + 2, column=3, sticky="w", padx=5, pady=5)
	#border_color_button = tk.Button(root, text="Border Color", command=choose_bordercolor, bg=config2[0]["bordercolor"], fg="#ffffff")
	#border_color_button.grid(row=row_offset + 3, column=4, sticky="e", padx=5, pady=5)
	roi_calc_button = tk.Button(root, text="ROI raw count", command=calc_roi_raw, fg=f"#{random.randint(0, 120):02x}{random.randint(0, 110):02x}{random.randint(0, 115):02x}")
	roi_calc_button.grid(row=row_offset + 4, column=0, sticky="w", padx=5, pady=5)
	show_meta_button = tk.Button(root, text="Show metadata", command=show_meta_data, fg=f"#{random.randint(0, 115):02x}{random.randint(0, 130):02x}{random.randint(0, 110):02x}")#random_color())
	show_meta_button.grid(row=row_offset + 1, column=0, sticky="w", padx=5, pady=5)
	export_csv_button = tk.Button(root, text="Convert to .csv", command=csv_export, fg=f"#{random.randint(0, 115):02x}{random.randint(0, 130):02x}{random.randint(0, 110):02x}")#random_color())
	export_csv_button.grid(row=row_offset + 2, column=0, sticky="w", padx=5, pady=5)
	export_hdtv_button = tk.Button(root, text="Export for HDTV", command=export_hdtv, fg=f"#{random.randint(0, 115):02x}{random.randint(0, 130):02x}{random.randint(0, 110):02x}")#random_color())
	export_hdtv_button.grid(row=row_offset + 1, column=0, sticky="n", padx=5, pady=5)
	export_xlsx_button = tk.Button(root, text="Export to .xlsx", command=makeXlsx, fg=f"#{random.randint(0, 115):02x}{random.randint(0, 130):02x}{random.randint(0, 110):02x}")#random_color())
	export_xlsx_button.grid(row=row_offset + 2, column=0, sticky="n", padx=5, pady=5)
	# ~ roi_color_button.config(bg=random_color)  # Ändere die Hintergrundfarbe des Buttons
	

	# Checkboxen
	grid_var = tk.BooleanVar(value=False)
	logscale_var = tk.BooleanVar(value=False)
	dividelive_var = tk.BooleanVar(value=False)
	tk.Checkbutton(root, text="grid", variable=gridcheck_var).grid(row=row_offset + 4, column=2, sticky="w", padx=5, pady=5)
	tk.Checkbutton(root, text="logscale", variable=logcheck_var).grid(row=row_offset + 4, column=3, sticky="w", padx=5, pady=5)
	tk.Checkbutton(root, text="divide by livetime", variable=divliv_var, command=on_live_check).grid(row=row_offset + 4, column=4, sticky="w", padx=5, pady=5)
	# ~ livecheck.bind("<KeyRelease>", lambda print: print("HI"))

	# Dropdown-Menues
	plot_type_var = tk.StringVar(value="Filled steps")
	plot_dropdown = ttk.Combobox(root, textvariable=plotstyle_var, values=["Standard", "Standard filled", "Steps", "Filled steps", "Impulses", "Surprise"], state="readonly")
	plot_dropdown.grid(row=row_offset + 5, column=0, columnspan=2, sticky="e", padx=5, pady=5)
	plot_dropdown.bind("<<ComboboxSelected>>", update_checkbox_text_color)
	auto_start_var = tk.StringVar(value="No automation")
	auto_start_dropdown = ttk.Combobox(root, textvariable=automation_var, values=["No automation", "Auto plot", "Auto gp-export", "Auto ROI count", "Auto add", "Auto subtract (>= 0)", "Auto subtract (neg. allowed)", "Auto spe-to-csv", "Auto to xlsx", "Auto to HDTV", "Auto metadata export"], state="readonly")
	auto_start_dropdown.grid(row=row_offset + 7, column=0, columnspan=2, sticky="sw", padx=5, pady=5)
	if noargs:
		print("No args: automation destroyed")
		automation_var.set("No automation")
	
		
	# Radiobuttons
	output_format_var = tk.StringVar(value="interactive window")
	tk.Radiobutton(root, text="pdf", variable=outputradio_var, value="pdf").grid(row=row_offset + 6, column=2, sticky="w", padx=5, pady=5)
	tk.Radiobutton(root, text="png", variable=outputradio_var, value="png").grid(row=row_offset + 6, column=3, sticky="w", padx=5, pady=5)
	tk.Radiobutton(root, text="interactive window", variable=outputradio_var, value="interactive window").grid(row=row_offset + 6, column=4, sticky="w", padx=5, pady=5)

	#Outputfilename an plotting-way
	#plotway_var = tk.StringVar(value="Single plot energy")
	plotway_dropdown =  ttk.Combobox(root, textvariable=plotway_var, values=["Single plot energy", "Single plot channels", "Multiple plots energy", "Multiple plots channels"], state="readonly")
	plotway_dropdown.grid(row=row_offset + 5, column=2, columnspan=2, sticky="w", padx=5, pady=5)
	plotway_dropdown.bind("<<ComboboxSelected>>", update_textfield)  # Event binden
	# Textfeld für Single File Output Name
	#single_file_output_var = tk.StringVar(value="")
	tk.Label(root, text="Save as (no extension)").grid(row=row_offset + 6, column=0, sticky="w", padx=5, pady=5)
	single_file_output_entry = tk.Entry(root, textvariable=outputname_var, width=25)
	single_file_output_entry.grid(row=row_offset + 7, column=0, columnspan=2, sticky="nw", padx=5, pady=5)
	# Beschriftung für das Textfeld
	tk.Label(root, text="<<-- Single file output name | How to plot -->>").grid(row=row_offset + 6, column=0, columnspan=2, sticky="e", padx=5, pady=5)
	
	# Buttons
	bold_font = font.Font(weight="bold", size=16)
	italic_font = font.Font(slant="italic")  # Kursivschrift

	tk.Button(root, text="Advanced Settings", command=lambda: open_settings_window(config2[0])).grid(row=row_offset + 7, column=0, sticky="e", padx=5, pady=10)
	tk.Button(root, text="Help", command=open_help_window, font=("TkDefaultFont",12)).grid(row=row_offset + 7, column=2, sticky="w", padx=5, pady=10)
	tk.Button(
		root,
		text="Export .gp",
		font=italic_font,
		command=export_gp  # Funktion zum Exportieren
	).grid(row=row_offset + 7, column=3, sticky="e", padx=5, pady=10)

	tk.Button(root, text="Subtract", command=subtract_spectra, fg=f"#{random.randint(0, 100):02x}{random.randint(0, 110):02x}{random.randint(0, 115):02x}").grid(row=row_offset + 3, column=0, padx=5, pady=10)
	tk.Button(root, text="Add", command=add_spectra, fg=f"#{random.randint(0, 120):02x}{random.randint(0, 105):02x}{random.randint(0, 125):02x}").grid(row=row_offset + 3, column=0, sticky="w", padx=5, pady=10)
	# ~ tk.Button(root, text="Plot!").grid(row=row_offset + 7, column=3, padx=5, pady=10)
	tk.Button(
		root, 
		text="Plot!", 
		command=plotgo,
		font=bold_font,  # Fett und größere Schrift
		height=2,  # Höhe in Textzeilen
		width=15,   # Breite in Zeichen
		fg="#ffffff",
		bg="#000000"
	).grid(row=row_offset + 7, column=4, padx=5, pady=10)

	widgets_extra.append({
		"xlabel": xlabel_var,
		"xrange1": xrange1_var,  # 
		"xrange2": xrange2_var,  # 
		"ylabel": ylabel_var,  # 
		"yrange1": yrange1_var,  #
		"yrange2": yrange2_var,  
		"gridcheck": gridcheck_var,
		"logcheck": logcheck_var,
		"plotstyle": plotstyle_var,
		"outputradio": outputradio_var,
		"plotway" : plotway_var,
		"outputname": outputname_var,
		"roicolor": roi_color_var,
		"bordercolor": border_color_var,
		"xcolor": x_color_var,
		"ycolor": y_color_var,
		"displayroi": roi_var,
		"trans_var": trans_var,
		"divliv_var": divliv_var,
		"eff_var": eff_var,
		"title_var": title_var,
		# ~ "title_var": config2[0]["title_var"],
		"border_var": border_var,
		"automation_var": automation_var
	})
	handle_dropdown_selection(automation_var.get())
	# ~ handle_dropdown_selection(widgets_extra[0]["automation_var"].get()) #evtl mag Windows das so lieber
	# Konfiguration beim Schließen speichern
	def on_closing():
		# ~ print("roicolor.get")
		# ~ print(widgets_extra[0]["roicolor"].get())
		# ~ print("fongi2[0][roicolor]")
		# ~ print(config2[0]["roicolor"])
		for i, widget_set in enumerate(widgets):
			config1[i]["file_path"] = widget_set["file_path_var"].get()
			config1[i]["button_color"] = widget_set["button_color_var"].get()
			config1[i]["dropdown_value"] = widget_set["dropdown_var"].get()
			config1[i]["small_text"] = widget_set["small_text_var"].get()
		config2[0]["xlabel"] = widgets_extra[0]["xlabel"].get()
		config2[0]["xrange1"] = widgets_extra[0]["xrange1"].get()
		config2[0]["xrange2"] = widgets_extra[0]["xrange2"].get()
		config2[0]["ylabel"] = widgets_extra[0]["ylabel"].get()
		config2[0]["yrange1"] = widgets_extra[0]["yrange1"].get()
		config2[0]["yrange2"] = widgets_extra[0]["yrange2"].get()
		config2[0]["gridcheck"] = widgets_extra[0]["gridcheck"].get()
		config2[0]["logcheck"] = widgets_extra[0]["logcheck"].get()
		config2[0]["plotstyle"] = widgets_extra[0]["plotstyle"].get()
		# ~ config2[0][""] = widgets_extra[0][""].get()
		config2[0]["plotway"] = widgets_extra[0]["plotway"].get()
		config2[0]["outputname"] = widgets_extra[0]["outputname"].get()
		config2[0]["outputradio"] = widgets_extra[0]["outputradio"].get()
		######geht ja net###ged ja neddä## ~ config2[0]["roicolor"] = widgets_extra[0]["roicolor"].get()
		config2[0]["roicolor"] = roi_color_button.cget("bg") ############################HIER AUSNAHME WEIL GING NET ANDERS
		#config2[0]["xcolor"] = x_color_button.cget("bg") ############################HIER AUSNAHME WEIL GING NET ANDERS
		#config2[0]["ycolor"] = y_color_button.cget("bg") ############################HIER AUSNAHME WEIL GING NET ANDERS
		# ~ config2[0]["bordercolor"] = border_color_button.cget("bg") ############################HIER AUSNAHME WEIL GING NET ANDERS
		config2[0]["displayroi"] = widgets_extra[0]["displayroi"].get()
		config2[0]["trans_var"] = widgets_extra[0]["trans_var"].get()
		config2[0]["eff_var"] = widgets_extra[0]["eff_var"].get()
		config2[0]["divliv_var"] = widgets_extra[0]["divliv_var"].get()
		config2[0]["title_var"] = widgets_extra[0]["title_var"].get()
		config2[0]["border_var"] = widgets_extra[0]["border_var"].get()
		config2[0]["automation_var"] = widgets_extra[0]["automation_var"].get()
		save_config(config1,config2)
		if os.path.exists(tmp_file):
			os.remove(tmp_file)
		root.destroy()
		
	# ~ open_help_window()	
	
	# ~ open_settings_window(config2[0])
	root.protocol("WM_DELETE_WINDOW", on_closing)
	try:
		root.mainloop()  # Tkinter-Hauptschleife starten
	except KeyboardInterrupt:
		print("\nUser-Goodbye erkannt! Und tschuess Fenster...NO_SAVE_Goodbye my dear!")
		if os.path.exists(tmp_file):
			os.remove(tmp_file)
		root.quit()
		root.destroy()
	# ~ root.mainloop()

if __name__ == "__main__":
	main()

	
